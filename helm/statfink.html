<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>Statfink - PFL Fantasy Football</title>
    <link href="/statfink-styles.css" rel="stylesheet" type="text/css" media="all" />
</head>
<body onload="read_cont()">
    <div id="controls" class="controls">
        <div id="updatemsg" style="display: inline-block; font-size: 11px; color: #333;"></div>
    </div>
    <div id="lastupdate" class="lastupdate"></div>

    <div id="leaguediv">
        <table class="leaguetable" id="leaguetable" width="250">
            <thead></thead>
            <tbody>
                <tr>
                    <td class="fleague" id="fleague" colspan="2" nowrap="nowrap">Loading...</td>
                </tr>
            </tbody>
            <tfoot>
                <tr class="logofooter">
                    <td colspan="2" style="text-align: center; padding: 5px 0;">
                        <img src="/statfink_logo.png" alt="Statfink Fantasy Football Stat Tracker" style="width: 100%; max-width: 240px; height: auto;">
                    </td>
                </tr>
            </tfoot>
        </table>
        <div id="nfldiv" class="nfldiv">
            <table class="nfltable" id="nfltable" width="250">
                <thead></thead>
                <tbody>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
    </div>
    <div id="teams">
        <div id="team0div">
            <table class="matchuptable" id="team0" width="325px">
                <thead></thead>
                <tbody>
                    <tr id="fteam0row">
                        <td class="fteam" id="fteam0" colspan="5" nowrap="nowrap">Loading...</td>
                    </tr>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
        <div id="team1div">
            <table class="matchuptable" id="team1" width="325px">
                <thead></thead>
                <tbody>
                    <tr id="fteam1row">
                        <td class="fteam" id="fteam1" colspan="5" nowrap="nowrap">Loading...</td>
                    </tr>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
    </div>
</body>

<script>
    // Configuration
    var bench = 0;
    var breakout = 0;
    var matchup = 0;
    var view = 0;
    var league = "pfl";
    var weekover = 0;
    var iterations = 0;
    var teamchange = 1;
    var lastupdate = 0;
    var live = 1;
    var nextgame = 0;
    var currentMatchupId = null;
    var currentWeek = null;
    var currentSeason = null;
    var refreshInterval = null;
    var showDetails = false;
    var currentMatchupData = null;

    // Initialize layout
    if (view == 0) {
        document.getElementById("team0div").className = "floatleftpad";
        document.getElementById("team1div").className = "floatleft";
        document.getElementById("team0").className = "floatleft";
    }
    document.getElementById("teams").className = "absteams";
    document.getElementById("leaguediv").className = "absleague";

    // No menu handlers needed anymore
    

    // Removed menu handlers - no longer needed

    // Matchup row event handlers
    function matchupmouseover(e) {
        const target = e.currentTarget; // Use currentTarget to get the row, not the cell
        const rowId = target.id;
        if (!rowId) return;
        
        const matchIndex = rowId.substring(2, 3);
        const row1 = document.getElementById(`lm${matchIndex}r0`);
        const row2 = document.getElementById(`lm${matchIndex}r1`);
        
        if (row1) row1.className = "matchuprowhover";
        if (row2) row2.className = "matchuprowhover";
    }

    function matchupmouseout(e) {
        const target = e.currentTarget; // Use currentTarget to get the row, not the cell
        const rowId = target.id;
        if (!rowId) return;
        
        const matchIndex = rowId.substring(2, 3);
        const originalClass = matchIndex % 2 ? "matchuprow2" : "matchuprow1";
        const row1 = document.getElementById(`lm${matchIndex}r0`);
        const row2 = document.getElementById(`lm${matchIndex}r1`);
        
        if (row1) row1.className = originalClass;
        if (row2) row2.className = originalClass;
    }

    // Toggle details view
    function toggleDetails() {
        showDetails = !showDetails;
        if (currentMatchupData) {
            displayMatchup(currentMatchupData);
        }
    }

    // Open matchup in new window
    function openMatchupWindow() {
        if (currentMatchupId) {
            window.open(`/statfink/${currentSeason}/${currentWeek}?matchup=${currentMatchupId}`, '_blank');
        }
    }

    // Show injuries (placeholder)
    function showInjuries() {
        alert("Injuries feature coming soon!");
    }

    // Show defensive TDs (placeholder)
    function showDefensiveTDs() {
        alert("Defensive TDs feature coming soon!");
    }

    // Show safeties (placeholder)
    function showSafeties() {
        alert("Safeties feature coming soon!");
    }

    // Check for zero scores
    function checkZeroScores() {
        if (!currentMatchupData) return;
        
        let zeroPlayers = [];
        currentMatchupData.team1.starters.forEach(player => {
            if (player.stats.fantasy_points === 0) {
                zeroPlayers.push(`${currentMatchupData.matchup.team1_name}: ${player.name}`);
            }
        });
        currentMatchupData.team2.starters.forEach(player => {
            if (player.stats.fantasy_points === 0) {
                zeroPlayers.push(`${currentMatchupData.matchup.team2_name}: ${player.name}`);
            }
        });
        
        if (zeroPlayers.length > 0) {
            alert("Players with zero points:\n" + zeroPlayers.join("\n"));
        } else {
            alert("No players with zero points!");
        }
    }

    // Show scores file (placeholder)
    function showScoresFile() {
        alert("Scores file feature coming soon!");
    }
    

    // Parse URL to get year, week, and mode
    function parseUrl() {
        const path = window.location.pathname;
        const urlParams = new URLSearchParams(window.location.search);
        const matchupParam = urlParams.get('matchup');
        
        // Check if this is mock mode with week
        const mockMatch = path.match(/\/statfink\/mock\/(\d+)/);
        if (mockMatch) {
            return {
                isMock: true,
                week: parseInt(mockMatch[1]),
                matchup: matchupParam
            };
        }
        
        // Check if this is mock mode without week
        if (path.includes('/statfink/mock')) {
            return {
                isMock: true,
                matchup: matchupParam
            };
        }
        
        // Parse /statfink/year/week format
        const pathParts = path.split('/');
        if (pathParts.length >= 4 && pathParts[1] === 'statfink') {
            const year = parseInt(pathParts[2]);
            const week = parseInt(pathParts[3]);
            
            if (!isNaN(year) && !isNaN(week)) {
                return {
                    year: year,
                    week: week,
                    matchup: matchupParam,
                    isMock: false
                };
            }
        }
        
        // Fallback to query parameters for backwards compatibility
        return {
            year: urlParams.get('season'),
            week: urlParams.get('week'),
            matchup: matchupParam,
            isMock: false
        };
    }

    // Main initialization
    async function read_cont() {
        try {
            // Parse URL for year/week/mode
            const urlData = parseUrl();
            
            // Load league settings
            const settingsResponse = await fetch('/api/league/settings');
            const settings = await settingsResponse.json();
            
            if (settings.success) {
                // Use URL parameters if available, otherwise use current settings
                currentWeek = parseInt(urlData.week) || settings.data.current_week;
                currentSeason = parseInt(urlData.year) || settings.data.season_year;
                
                // Check for mock mode
                if (urlData.isMock) {
                    document.getElementById("fleague").innerHTML = `Week ${currentWeek}<br>Mock Mode`;
                    document.getElementById("updatemsg").innerHTML = "MOCK DATA - Testing Mode";
                    document.getElementById("updatemsg").style.color = "#ff6600";
                    document.getElementById("updatemsg").style.fontWeight = "bold";
                } else {
                    document.getElementById("fleague").innerHTML = `Week ${currentWeek}`;
                }
            }

            // Load matchups for current week
            await loadWeekMatchups();
            
            // Load NFL games
            await loadNFLGames();
            
            // If specific matchup requested, load it
            if (urlData.matchup) {
                currentMatchupId = parseInt(urlData.matchup);
                await loadMatchup(currentMatchupId);
            } else if (matchup === 0 && document.getElementById("leaguetable").rows.length > 1) {
                // Load first matchup by default
                document.getElementById("leaguetable").rows[1].click();
            }

            // Start refresh interval (30 seconds) - but not in mock mode to avoid API calls
            if (!urlData.isMock) {
                refreshInterval = setInterval(refreshData, 30000);
            }
            
        } catch (error) {
            console.error('Error initializing:', error);
            document.getElementById("fleague").textContent = "Error loading league data";
        }
    }

    // Load all matchups for the week
    async function loadWeekMatchups() {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock/${currentWeek}/${currentSeason}`
                : `/api/matchups/${currentWeek}/${currentSeason}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                const tbody = document.getElementById("leaguetable").getElementsByTagName("tbody")[0];
                
                // Keep the header row
                while (tbody.rows.length > 1) {
                    tbody.deleteRow(1);
                }
                
                // Add matchup rows in original format
                data.data.forEach((matchup, index) => {
                    // Team 1 row
                    const row1 = tbody.insertRow(-1);
                    row1.className = index % 2 ? "matchuprow2" : "matchuprow1";
                    row1.id = `lm${index}r0`;
                    row1.onclick = () => selectMatchup(matchup.matchup_id);
                    row1.onmouseover = matchupmouseover;
                    row1.onmouseout = matchupmouseout;
                    
                    const team1Cell = row1.insertCell(0);
                    // For mock week 1 pre-game, all 11 players haven't started
                    const playersRemaining = (isMockMode && currentWeek === 1 && !matchup.is_complete) ? 11 : 0;
                    team1Cell.textContent = `${matchup.team1_owner} (${playersRemaining})`;
                    team1Cell.nowrap = true;
                    
                    const score1Cell = row1.insertCell(1);
                    score1Cell.textContent = matchup.team1_points.toFixed(2);
                    score1Cell.align = "right";
                    score1Cell.className = "fanpts";
                    score1Cell.nowrap = true;
                    
                    // Team 2 row
                    const row2 = tbody.insertRow(-1);
                    row2.className = index % 2 ? "matchuprow2" : "matchuprow1";
                    row2.id = `lm${index}r1`;
                    row2.onclick = () => selectMatchup(matchup.matchup_id);
                    row2.onmouseover = matchupmouseover;
                    row2.onmouseout = matchupmouseout;
                    
                    const team2Cell = row2.insertCell(0);
                    // Use same players remaining count as team1
                    team2Cell.textContent = `${matchup.team2_owner} (${playersRemaining})`;
                    team2Cell.nowrap = true;
                    
                    const score2Cell = row2.insertCell(1);
                    score2Cell.textContent = matchup.team2_points.toFixed(2);
                    score2Cell.align = "right";
                    score2Cell.className = "fanpts";
                    score2Cell.nowrap = true;
                    
                    if (index === 0) {
                        currentMatchupId = matchup.matchup_id;
                    }
                });
                
                updateLastUpdate();
                
                // Apply the appropriate background class to the logo footer
                const logoFooter = document.querySelector('.logofooter');
                if (logoFooter && data.data.length > 0) {
                    // The last matchup row determines the background pattern
                    const lastMatchupIndex = data.data.length - 1;
                    const bgClass = lastMatchupIndex % 2 ? 'matchuprow1' : 'matchuprow2';
                    logoFooter.className = 'logofooter ' + bgClass;
                }
                
                // No longer need to load scoring totals - backend provides them
            }
        } catch (error) {
            console.error('Error loading matchups:', error);
        }
    }

    // Select and load a specific matchup
    async function selectMatchup(matchupId) {
        currentMatchupId = matchupId;
        await loadMatchup(matchupId);
        
        // Update browser URL to reflect current matchup
        updateUrlWithMatchup(matchupId);
    }
    
    // Update browser URL with current matchup
    function updateUrlWithMatchup(matchupId) {
        const currentPath = window.location.pathname;
        const isMockMode = currentPath.includes('/statfink/mock');
        
        let newUrl;
        if (isMockMode) {
            newUrl = `/statfink/mock/${currentWeek}?matchup=${matchupId}`;
        } else {
            newUrl = `/statfink/${currentSeason}/${currentWeek}?matchup=${matchupId}`;
        }
        
        // Update URL without reloading the page
        history.pushState({ matchupId: matchupId }, '', newUrl);
    }


    // Load matchup details
    async function loadMatchup(matchupId) {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock-game/${matchupId}?week=${currentWeek}&season=${currentSeason}`
                : `/api/matchups/game/${matchupId}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                currentMatchupData = data.data;
                displayMatchup(data.data);
                updateLastUpdate();
            }
        } catch (error) {
            console.error('Error loading matchup:', error);
        }
    }

    // Display matchup data
    function displayMatchup(data) {
        const matchup = data.matchup;
        
        // Calculate players not started yet
        const team1Remaining = data.team1.starters.filter(p => 
            p.game_status === 'Scheduled' || (!p.game_status && !matchup.is_complete)
        ).length;
        const team2Remaining = data.team2.starters.filter(p => 
            p.game_status === 'Scheduled' || (!p.game_status && !matchup.is_complete)
        ).length;
        
        // Update team headers
        document.getElementById("fteam0").innerHTML = `${matchup.team1_owner} (${team1Remaining})`;
        document.getElementById("fteam1").innerHTML = `${matchup.team2_owner} (${team2Remaining})`;
        
        // Build team tables and get scoring totals
        const team1ScoringTotal = displayTeamRoster("team0", data.team1.starters, matchup.team1_name);
        const team2ScoringTotal = displayTeamRoster("team1", data.team2.starters, matchup.team2_name);
    }

    // This function is no longer needed - backend provides scoring totals
    async function loadAllMatchupScoringTotals_DEPRECATED(matchups) {
        try {
            // Process each matchup to calculate scoring totals
            for (const matchup of matchups) {
                // Skip if already calculated
                if (scoringTotalsCache[matchup.matchup_id]) {
                    updateMatchupScoreDisplay(matchup.matchup_id, 
                        scoringTotalsCache[matchup.matchup_id].team1,
                        scoringTotalsCache[matchup.matchup_id].team2);
                    continue;
                }
                
                // Fetch matchup details
                const isMockMode = window.location.pathname.includes('/statfink/mock');
                const apiUrl = isMockMode 
                    ? `/api/matchups/mock-game/${matchup.matchup_id}?week=${currentWeek}&season=${currentSeason}`
                    : `/api/matchups/game/${matchup.matchup_id}`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                if (data.success) {
                    // Calculate scoring players for both teams
                    const team1Scoring = calculateScoringPlayers(data.data.team1.starters);
                    const team2Scoring = calculateScoringPlayers(data.data.team2.starters);
                    
                    // Calculate totals
                    let team1Total = 0;
                    let team2Total = 0;
                    
                    data.data.team1.starters.forEach(player => {
                        if (team1Scoring.has(player)) {
                            team1Total += player.stats ? player.stats.fantasy_points : 0;
                        }
                    });
                    
                    data.data.team2.starters.forEach(player => {
                        if (team2Scoring.has(player)) {
                            team2Total += player.stats ? player.stats.fantasy_points : 0;
                        }
                    });
                    
                    // Cache and update display
                    scoringTotalsCache[matchup.matchup_id] = {
                        team1: team1Total,
                        team2: team2Total
                    };
                    
                    updateMatchupScoreDisplay(matchup.matchup_id, team1Total, team2Total);
                }
                
                // Small delay to avoid overwhelming the server
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        } catch (error) {
            console.error('Error loading scoring totals:', error);
        }
    }

    // Update matchup score display in the left panel
    function updateMatchupScoreDisplay(matchupId, team1Score, team2Score) {
        // Find the matchup rows
        const rows = document.getElementById("leaguetable").getElementsByTagName("tbody")[0].rows;
        
        for (let i = 1; i < rows.length; i += 2) {
            const row1 = rows[i];
            const row2 = rows[i + 1];
            
            if (row1 && row1.onclick) {
                // Extract matchup ID from the onclick handler
                const onclickStr = row1.onclick.toString();
                if (onclickStr.includes(`selectMatchup(${matchupId})`)) {
                    // Update scores
                    const score1Cell = row1.cells[1];
                    const score2Cell = row2.cells[1];
                    
                    if (score1Cell) {
                        score1Cell.textContent = team1Score.toFixed(2);
                        score1Cell.style.fontWeight = 'bold';
                        score1Cell.style.color = '#000'; // Black for final scoring total
                        score1Cell.title = "Scoring players total";
                    }
                    if (score2Cell) {
                        score2Cell.textContent = team2Score.toFixed(2);
                        score2Cell.style.fontWeight = 'bold';
                        score2Cell.style.color = '#000'; // Black for final scoring total
                        score2Cell.title = "Scoring players total";
                    }
                    break;
                }
            }
        }
    }

    // This function is no longer needed - backend provides is_scoring flag
    function calculateScoringPlayers_DEPRECATED(starters) {
        // Create a Set to store scoring players
        const scoringPlayers = new Set();
        
        // Sort players by fantasy points (highest first)
        const sortedPlayers = [...starters].sort((a, b) => {
            const pointsA = a.stats ? a.stats.fantasy_points : 0;
            const pointsB = b.stats ? b.stats.fantasy_points : 0;
            return pointsB - pointsA;
        });
        
        // Track how many of each position we've selected
        const positionCounts = {
            QB: 0,
            RB: 0,
            WR_TE: 0,  // Combined WR/TE
            K: 0,
            DST: 0,
            BONUS: 0
        };
        
        // Position limits based on scoring rules
        const limits = {
            QB: 1,
            RB: 4,
            WR_TE: 4,
            K: 1,
            DST: 2,  // This will be handled separately (best points/yards allowed)
            BONUS: 1
        };
        
        // First pass: Fill required position slots (skip players with 0 points)
        sortedPlayers.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            if (points === 0) return; // Skip players with 0 points
            
            const pos = player.position;
            
            if (pos === 'QB' && positionCounts.QB < limits.QB) {
                scoringPlayers.add(player);
                positionCounts.QB++;
            } else if (pos === 'RB' && positionCounts.RB < limits.RB) {
                scoringPlayers.add(player);
                positionCounts.RB++;
            } else if ((pos === 'WR' || pos === 'TE') && positionCounts.WR_TE < limits.WR_TE) {
                scoringPlayers.add(player);
                positionCounts.WR_TE++;
            } else if (pos === 'K' && positionCounts.K < limits.K) {
                scoringPlayers.add(player);
                positionCounts.K++;
            } else if ((pos === 'DST' || pos === 'DEF') && positionCounts.DST < limits.DST) {
                // For DST, we should ideally pick best points allowed and best yards allowed
                // For now, just take top 2 DST by fantasy points
                scoringPlayers.add(player);
                positionCounts.DST++;
            }
        });
        
        // Second pass: Fill bonus slots with highest scoring remaining players (skip 0 point players)
        sortedPlayers.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            if (points === 0) return; // Skip players with 0 points
            
            if (!scoringPlayers.has(player) && positionCounts.BONUS < limits.BONUS) {
                // Any position can be a bonus player
                scoringPlayers.add(player);
                positionCounts.BONUS++;
            }
        });
        
        return scoringPlayers;
    }

    // Display team roster
    function displayTeamRoster(tableId, starters, teamName) {
        const table = document.getElementById(tableId);
        const tbody = table.getElementsByTagName("tbody")[0];
        
        // Clear existing rows except header
        while (tbody.rows.length > 1) {
            tbody.deleteRow(1);
        }
        
        // Add header row
        const headerRow = tbody.insertRow(-1);
        headerRow.className = "pointsrow";
        headerRow.innerHTML = `
            <td>Pos</td>
            <td>Player</td>
            <td align="right" nowrap>Game Status</td>
            <td class="opp">Opp</td>
            <td align="right">FanPts</td>
        `;
        
        let totalPoints = 0;
        let scoringTotalPoints = 0;
        let rowIndex = 0;
        
        starters.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            totalPoints += points;
            
            // Check if this player is one of the scoring players (from backend)
            const isScoring = player.is_scoring === true;
            if (isScoring) {
                scoringTotalPoints += points;
            }
            
            // Player row
            const row = tbody.insertRow(-1);
            row.className = rowIndex % 2 ? "playerrow2" : "playerrow1";
            row.id = `t${tableId.slice(-1)}r${rowIndex}`;
            
            // Add asterisk if player is scoring
            const playerName = isScoring ? `*${player.name}` : player.name;
            
            row.innerHTML = `
                <td class="position position-${player.position}">${player.position}</td>
                <td class="playername" nowrap>${playerName} &nbsp;&nbsp;${player.team}<br>
                    <span style="font-size: 10px; color: #000; margin-top: 3px; display: block;">${formatPlayerStatsCompact(player.position, player.stats)}</span>
                </td>
                <td class="status" align="center">${getPlayerGameStatus(player)}</td>
                <td class="opp">${player.opp || '@OPP'}</td>
                <td class="points fanpts" align="right">${points.toFixed(2)}</td>
            `;
            
            rowIndex++;
        });
        
        // Add total row (show scoring total, not all players total)
        const totalRow = tbody.insertRow(-1);
        totalRow.className = "totalsrow";
        totalRow.innerHTML = `
            <td colspan="4" class="fanptsbig">Net Points</td>
            <td class="fanptsbig" align="right">${scoringTotalPoints.toFixed(2)}</td>
        `;
        
        return scoringTotalPoints;
    }

    // Format player stats based on position
    function formatPlayerStats(position, stats) {
        if (!stats) return 'No stats available';
        
        let details = [];
        
        switch(position) {
            case 'QB':
                if (stats.passing_yards > 0) details.push(`${stats.passing_yards} pass yds`);
                if (stats.passing_tds > 0) details.push(`${stats.passing_tds} pass TD`);
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} rush yds`);
                if (stats.rushing_tds > 0) details.push(`${stats.rushing_tds} rush TD`);
                if (stats.interceptions > 0) details.push(`${stats.interceptions} INT`);
                break;
            case 'RB':
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} rush yds`);
                if (stats.rushing_tds > 0) details.push(`${stats.rushing_tds} rush TD`);
                if (stats.receptions > 0) details.push(`${stats.receptions} rec`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} rec yds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} rec TD`);
                break;
            case 'WR':
            case 'TE':
                if (stats.receptions > 0) details.push(`${stats.receptions} rec`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} rec yds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} rec TD`);
                break;
            case 'K':
                if (stats.field_goals_made > 0) details.push(`${stats.field_goals_made}/${stats.field_goals_attempted} FG`);
                if (stats.extra_points_made > 0) details.push(`${stats.extra_points_made}/${stats.extra_points_attempted} XP`);
                break;
            case 'DST':
            case 'DEF':
                if (stats.sacks > 0) details.push(`${stats.sacks} sacks`);
                if (stats.def_interceptions > 0) details.push(`${stats.def_interceptions} INT`);
                if (stats.fumbles_recovered > 0) details.push(`${stats.fumbles_recovered} FR`);
                if (stats.def_touchdowns > 0) details.push(`${stats.def_touchdowns} TD`);
                if (stats.points_allowed !== undefined) details.push(`${stats.points_allowed} PtsAllw`);
                if (stats.yards_allowed !== undefined) details.push(`${stats.yards_allowed} YdsAllw`);
                break;
        }
        
        return details.join(', ') || 'No stats';
    }

    // Get player game status (show time if not started, Final if complete)
    function getPlayerGameStatus(player) {
        if (player.game_status === 'Scheduled' && player.game_time) {
            // Convert ET to PST
            return convertToPST(player.game_time);
        }
        return player.game_status || 'Final';
    }
    
    // Convert ET time to PST
    function convertToPST(etTime) {
        // Simple conversion - subtract 3 hours
        const match = etTime.match(/(\d+):(\d+) (AM|PM) ET/);
        if (!match) return etTime;
        
        let hours = parseInt(match[1]);
        const minutes = match[2];
        const period = match[3];
        
        // Convert to 24-hour format
        if (period === 'PM' && hours !== 12) hours += 12;
        if (period === 'AM' && hours === 12) hours = 0;
        
        // Subtract 3 hours for PST
        hours -= 3;
        
        // Handle negative hours
        if (hours < 0) {
            hours += 12;
            // If it was PM, it becomes AM and vice versa
            const newPeriod = period === 'PM' ? 'AM' : 'PM';
            return `${hours === 0 ? 12 : hours}:${minutes} ${newPeriod} PST`;
        }
        
        // Convert back to 12-hour format
        const newPeriod = hours >= 12 ? 'PM' : 'AM';
        if (hours > 12) hours -= 12;
        if (hours === 0) hours = 12;
        
        return `${hours}:${minutes} ${newPeriod} PST`;
    }

    // Format player stats in compact form like original Statfink
    function formatPlayerStatsCompact(position, stats) {
        if (!stats) return '0 Stats';
        
        let details = [];
        
        switch(position) {
            case 'QB':
                if (stats.completions > 0) details.push(`${stats.completions} Comp`);
                if (stats.passing_attempts - stats.completions > 0) details.push(`${stats.passing_attempts - stats.completions} Inc`);
                if (stats.passing_yards > 0) details.push(`${stats.passing_yards} Pyds`);
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} Rshyds`);
                if (stats.passing_tds + stats.rushing_tds > 0) details.push(`${stats.passing_tds + stats.rushing_tds} TDs`);
                if (stats.two_point_conversions_pass > 0) details.push(`${stats.two_point_conversions_pass} 2PC`);
                break;
            case 'RB':
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} Rshyds`);
                if (stats.receptions > 0) details.push(`${stats.receptions} Recs`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} Recyds`);
                if (stats.rushing_tds + stats.receiving_tds > 0) details.push(`${stats.rushing_tds + stats.receiving_tds} TDs`);
                if (stats.two_point_conversions_run + stats.two_point_conversions_rec > 0) {
                    details.push(`${stats.two_point_conversions_run + stats.two_point_conversions_rec} 2PC`);
                }
                break;
            case 'WR':
            case 'TE':
                if (stats.receptions > 0) details.push(`${stats.receptions} Recs`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} Recyds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} TDs`);
                if (stats.two_point_conversions_rec > 0) details.push(`${stats.two_point_conversions_rec} 2PC`);
                break;
            case 'K':
                if (stats.field_goals_made > 0) details.push(`${stats.field_goals_made} FG`);
                if (stats.extra_points_made > 0) details.push(`${stats.extra_points_made} XP`);
                break;
            case 'DST':
            case 'DEF':
                if (stats.sacks > 0) details.push(`${stats.sacks} Sck`);
                if (stats.def_interceptions > 0) details.push(`${stats.def_interceptions} Int`);
                if (stats.fumbles_recovered > 0) details.push(`${stats.fumbles_recovered} FR`);
                if (stats.def_touchdowns > 0) details.push(`${stats.def_touchdowns} TD`);
                if (stats.points_allowed !== undefined) details.push(`${stats.points_allowed} PtsAllw`);
                if (stats.yards_allowed !== undefined) details.push(`${stats.yards_allowed} YdsAllw`);
                break;
        }
        
        if (details.length === 0) {
            return '0 Stats';
        }
        
        return details.join(', ');
    }

    // Update last update time
    async function updateLastUpdate() {
        try {
            const response = await fetch('/api/league/sync-status');
            const data = await response.json();
            
            if (data.success && data.data.last_sync_time) {
                const syncTime = new Date(data.data.last_sync_time);
                document.getElementById("lastupdate").textContent = `Last Tank01 Sync: ${syncTime.toLocaleString()}`;
            } else {
                const now = new Date();
                document.getElementById("lastupdate").textContent = `Last Update: ${now.toLocaleTimeString()}`;
            }
        } catch (error) {
            console.error('Error fetching sync status:', error);
            const now = new Date();
            document.getElementById("lastupdate").textContent = `Last Update: ${now.toLocaleTimeString()}`;
        }
        
        // Update the message next to Options with current time
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
        });
        const dateString = now.toLocaleDateString('en-US', { 
            month: 'numeric', 
            day: 'numeric',
            year: '2-digit'
        });
        document.getElementById("updatemsg").textContent = `Updated ${dateString}, ${timeString}`;
        // Reset color to default (not orange) for regular updates
        document.getElementById("updatemsg").style.color = "#333";
        document.getElementById("updatemsg").style.fontWeight = "normal";
    }

    // Refresh data
    async function refreshData() {
        if (currentMatchupId) {
            await loadMatchup(currentMatchupId);
        }
        await loadWeekMatchups();
        await loadNFLGames();
    }

    // Highlight NFL game on hover
    function highlightGame(cells, highlight) {
        cells.forEach(cell => {
            if (highlight) {
                // Store original classes
                cell.dataset.originalClass = cell.className;
                // Apply highlight classes
                if (cell.className.includes('pts')) {
                    cell.className = 'nflhlpts';
                } else if (cell.className.includes('status')) {
                    cell.className = 'nflhlstatus';
                } else {
                    cell.className = 'nflhl';
                }
            } else {
                // Restore original classes
                if (cell.dataset.originalClass) {
                    cell.className = cell.dataset.originalClass;
                }
            }
        });
    }
    
    // Load NFL games for the week
    async function loadNFLGames() {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/nfl-games/mock/${currentWeek}/${currentSeason}`
                : `/api/nfl-games/${currentWeek}/${currentSeason}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success && data.data.length > 0) {
                displayNFLGames(data.data);
            }
        } catch (error) {
            console.error('Error loading NFL games:', error);
        }
    }
    
    // Display NFL games in grid format
    function displayNFLGames(games) {
        const tbody = document.getElementById('nfltable').getElementsByTagName('tbody')[0];
        tbody.innerHTML = ''; // Clear existing content
        
        // Group games into rows (4 games per row)
        const gamesPerRow = 4;
        const rows = [];
        
        for (let i = 0; i < games.length; i += gamesPerRow) {
            rows.push(games.slice(i, i + gamesPerRow));
        }
        
        // Create table rows with exact HTML structure
        rows.forEach((rowGames, rowIndex) => {
            // Create rows using exact HTML from reference
            const tr1 = document.createElement('tr');
            tr1.id = `nfl${rowIndex}r0`;
            
            const tr2 = document.createElement('tr');
            tr2.id = `nfl${rowIndex}r1`;
            
            const tr3 = document.createElement('tr');
            tr3.id = `nfl${rowIndex}rs`;
            
            // Process each game in this row
            rowGames.forEach((game, colIndex) => {
                const gameIndex = rowIndex * gamesPerRow + colIndex;
                
                // Create checkered pattern based on row and column position
                const isEven = (rowIndex + colIndex) % 2 === 0;
                const baseClass = isEven ? 'nfl1' : 'nfl2';
                const ptsClass = isEven ? 'nfl1pts' : 'nfl2pts';
                const statusClass = isEven ? 'nfl1status' : 'nfl2status';
                
                // Row 1: Away team and score
                const awayTeamCell = document.createElement('td');
                awayTeamCell.id = `g${gameIndex}nfl${rowIndex}r0c${colIndex * 2}`;
                awayTeamCell.className = baseClass;
                awayTeamCell.setAttribute('nowrap', '');
                awayTeamCell.title = game.status;
                awayTeamCell.textContent = game.away_team;
                
                const awayScoreCell = document.createElement('td');
                awayScoreCell.id = `g${gameIndex}nfl${rowIndex}r0c${colIndex * 2 + 1}p`;
                awayScoreCell.className = ptsClass;
                awayScoreCell.setAttribute('nowrap', '');
                awayScoreCell.align = 'right';
                awayScoreCell.title = game.status;
                awayScoreCell.textContent = game.status === 'Scheduled' ? '0' : game.away_score;
                
                tr1.appendChild(awayTeamCell);
                tr1.appendChild(awayScoreCell);
                
                // Row 2: Home team and score
                const homeTeamCell = document.createElement('td');
                homeTeamCell.id = `g${gameIndex}nfl${rowIndex}r1c${colIndex * 2}`;
                homeTeamCell.className = baseClass;
                homeTeamCell.setAttribute('nowrap', '');
                homeTeamCell.title = game.status;
                homeTeamCell.textContent = game.home_team;
                
                const homeScoreCell = document.createElement('td');
                homeScoreCell.id = `g${gameIndex}nfl${rowIndex}r1c${colIndex * 2 + 1}p`;
                homeScoreCell.className = ptsClass;
                homeScoreCell.setAttribute('nowrap', '');
                homeScoreCell.align = 'right';
                homeScoreCell.title = game.status;
                homeScoreCell.textContent = game.status === 'Scheduled' ? '0' : game.home_score;
                
                tr2.appendChild(homeTeamCell);
                tr2.appendChild(homeScoreCell);
                
                // Row 3: Status
                const statusCell = document.createElement('td');
                statusCell.id = `g${gameIndex}nfl${rowIndex}rs`;
                statusCell.className = statusClass;
                statusCell.setAttribute('nowrap', '');
                statusCell.colSpan = 2;
                statusCell.title = game.status;
                // Show game time in PST for scheduled games
                if (game.status === 'Scheduled' && game.game_time) {
                    statusCell.textContent = convertToPST(game.game_time);
                } else {
                    statusCell.textContent = game.status;
                }
                
                tr3.appendChild(statusCell);
                
                // Add hover and click effects
                const cells = [awayTeamCell, awayScoreCell, homeTeamCell, homeScoreCell, statusCell];
                cells.forEach(cell => {
                    cell.addEventListener('mouseenter', () => highlightGame(cells, true));
                    cell.addEventListener('mouseleave', () => highlightGame(cells, false));
                    // Add click handler to open CBS Sports game page
                    cell.addEventListener('click', () => {
                        if (game.game_url) {
                            window.open(game.game_url, '_blank');
                        }
                    });
                });
            });
            
            tbody.appendChild(tr1);
            tbody.appendChild(tr2);
            tbody.appendChild(tr3);
        });
        
        // Show the NFL games div
        document.getElementById('nfldiv').style.display = 'block';
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function(event) {
        const urlData = parseUrl();
        if (urlData.matchup) {
            currentMatchupId = parseInt(urlData.matchup);
            loadMatchup(currentMatchupId);
        }
    });

    // Clean up on unload
    window.onbeforeunload = function() {
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }
    };
</script>
</body>
</html>