<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>Statfink - PFL Fantasy Football</title>
    <link href="/statfink-styles.css" rel="stylesheet" type="text/css" media="all" />
</head>
<body onload="read_cont()">
    <div id="controls" class="controls" style="display: none;">
        <div id="updatemsg" style="display: inline-block; font-size: 11px; color: #333;"></div>
    </div>
    <div id="lastupdate" class="lastupdate" style="display: none;"></div>

    <div id="leaguediv">
        <table class="leaguetable" id="leaguetable" width="250">
            <thead></thead>
            <tbody>
                <tr>
                    <td class="fleague" id="fleague" colspan="2" nowrap="nowrap">Loading...</td>
                </tr>
            </tbody>
            <tfoot>
                <tr class="logofooter">
                    <td colspan="2" style="text-align: center; padding: 5px 0;">
                        <img src="/statfink_logo.png" alt="Statfink Fantasy Football Stat Tracker" style="width: 100%; max-width: 240px; height: auto;">
                    </td>
                </tr>
            </tfoot>
        </table>
        <div id="nfldiv" class="nfldiv">
            <table class="nfltable" id="nfltable" width="250">
                <thead></thead>
                <tbody>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
        <div style="margin-top: 15px; text-align: center;">
            <button id="standingsButton" 
                    onclick="navigateToStandings()" 
                    onmouseover="this.style.backgroundColor='#b83535'" 
                    onmouseout="this.style.backgroundColor='#556'" 
                    style="display: block; width: 200px; margin: 0 auto 8px auto; padding: 10px 25px; cursor: pointer; background-color: #556; color: white; border: 2px solid #343443; font-family: arial; font-size: 14px; font-weight: bold; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: all 0.2s;">
                üèÜ STANDINGS
            </button>
            <button id="rostersButton"
                    onclick="navigateToRosters()" 
                    onmouseover="this.style.backgroundColor='#b83535'" 
                    onmouseout="this.style.backgroundColor='#556'" 
                    style="display: block; width: 200px; margin: 0 auto; padding: 10px 25px; cursor: pointer; background-color: #556; color: white; border: 2px solid #343443; font-family: arial; font-size: 14px; font-weight: bold; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: all 0.2s;">
                üìã ROSTERS
            </button>
        </div>
    </div>
    <div id="teams">
        <div id="team0div">
            <table class="matchuptable" id="team0" width="325px">
                <thead></thead>
                <tbody>
                    <tr id="fteam0row">
                        <td class="fteam" id="fteam0" colspan="5" nowrap="nowrap">Loading...</td>
                    </tr>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
        <div id="team1div">
            <table class="matchuptable" id="team1" width="325px">
                <thead></thead>
                <tbody>
                    <tr id="fteam1row">
                        <td class="fteam" id="fteam1" colspan="5" nowrap="nowrap">Loading...</td>
                    </tr>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
    </div>
</body>

<script>
    // Configuration
    var bench = 0;
    var breakout = 0;
    var matchup = 0;
    var view = 0;
    var league = "pfl";
    var weekover = 0;
    var iterations = 0;
    var teamchange = 1;
    var lastupdate = 0;
    var live = 1;
    var nextgame = 0;
    var currentMatchupId = null;
    var currentWeek = null;
    var currentSeason = null;
    var showDetails = false;
    var currentMatchupData = null;
    var remainingPlayersCache = {}; // Cache for remaining players count
    
    // Memory-only session state for tracking changes
    var sessionStats = {}; // Current session baseline stats
    var sessionScores = {}; // Current session baseline scores
    var sessionStartTime = Date.now(); // Track when session started
    var isFirstLoad = true; // Track if this is the first data load
    
    // Global delta storage - persists across matchup navigation
    var globalDeltas = {
        players: {}, // playerId -> {delta: value, timestamp: time, changedStats: []}
        teams: {}    // "matchupId_team1/2" -> {delta: value, timestamp: time}
    };

    // Initialize layout
    if (view == 0) {
        document.getElementById("team0div").className = "floatleftpad";
        document.getElementById("team1div").className = "floatleft";
        document.getElementById("team0").className = "floatleft";
    }
    document.getElementById("teams").className = "absteams";
    document.getElementById("leaguediv").className = "absleague";

    // No menu handlers needed anymore
    

    // Removed menu handlers - no longer needed

    // Matchup row event handlers
    function matchupmouseover(e) {
        const target = e.currentTarget; // Use currentTarget to get the row, not the cell
        const rowId = target.id;
        if (!rowId) return;
        
        const matchIndex = rowId.substring(2, 3);
        const row1 = document.getElementById(`lm${matchIndex}r0`);
        const row2 = document.getElementById(`lm${matchIndex}r1`);
        
        if (row1) row1.className = "matchuprowhover";
        if (row2) row2.className = "matchuprowhover";
    }

    function matchupmouseout(e) {
        const target = e.currentTarget; // Use currentTarget to get the row, not the cell
        const rowId = target.id;
        if (!rowId) return;
        
        const matchIndex = rowId.substring(2, 3);
        const originalClass = matchIndex % 2 ? "matchuprow2" : "matchuprow1";
        const row1 = document.getElementById(`lm${matchIndex}r0`);
        const row2 = document.getElementById(`lm${matchIndex}r1`);
        
        if (row1) row1.className = originalClass;
        if (row2) row2.className = originalClass;
    }

    // Format long player names to use first initial
    function formatPlayerName(fullName, maxLength = 18) {
        if (!fullName || fullName.length <= maxLength) {
            return fullName;
        }
        
        // Split name into parts
        const parts = fullName.trim().split(/\s+/);
        
        // If single word name, return as is (shouldn't truncate)
        if (parts.length === 1) {
            return fullName;
        }
        
        // Get first name and convert to initial
        const firstName = parts[0];
        const firstInitial = firstName.charAt(0).toUpperCase() + '.';
        
        // Reconstruct with initial + rest of name
        const restOfName = parts.slice(1).join(' ');
        const shortened = firstInitial + ' ' + restOfName;
        
        // If still too long, return the shortened version anyway
        // (better than truncating with ellipsis)
        return shortened;
    }
    
    // Toggle details view
    function toggleDetails() {
        showDetails = !showDetails;
        if (currentMatchupData) {
            displayMatchup(currentMatchupData);
        }
    }

    // Open matchup in new window
    function openMatchupWindow() {
        if (currentMatchupId) {
            window.open(`/statfink/${currentSeason}/${currentWeek}?matchup=${currentMatchupId}`, '_blank');
        }
    }

    // Show injuries (placeholder)
    function showInjuries() {
        alert("Injuries feature coming soon!");
    }

    // Navigate to standings for the previous week
    function navigateToStandings() {
        if (currentWeek && currentSeason) {
            // Go to previous week's standings (minimum week 1)
            const previousWeek = Math.max(1, currentWeek - 1);
            window.location.href = `/standings/${currentSeason}/${previousWeek}`;
        } else {
            // Fallback to default standings page
            window.location.href = '/standings';
        }
    }

    // Navigate to rosters for the current week
    function navigateToRosters() {
        if (currentWeek && currentSeason) {
            // Always show current week's rosters
            window.location.href = `/rosters/${currentSeason}/${currentWeek}`;
        } else {
            // Fallback to default rosters page
            window.location.href = '/rosters';
        }
    }

    // Update standings and rosters button visibility based on current week
    function updateStandingsButtonVisibility() {
        const standingsButton = document.getElementById('standingsButton');
        const rostersButton = document.getElementById('rostersButton');
        
        // Hide only standings button for Week 1
        if (currentWeek === 1) {
            if (standingsButton) standingsButton.style.display = 'none';
            // Keep rosters button visible for Week 1
            if (rostersButton) rostersButton.style.display = 'block';
        } else {
            if (standingsButton) standingsButton.style.display = 'block';
            if (rostersButton) rostersButton.style.display = 'block';
        }
    }

    // Show defensive TDs (placeholder)
    function showDefensiveTDs() {
        alert("Defensive TDs feature coming soon!");
    }

    // Show safeties (placeholder)
    function showSafeties() {
        alert("Safeties feature coming soon!");
    }

    // Check for zero scores
    function checkZeroScores() {
        if (!currentMatchupData) return;
        
        let zeroPlayers = [];
        currentMatchupData.team1.starters.forEach(player => {
            if (player.stats.fantasy_points === 0) {
                zeroPlayers.push(`${currentMatchupData.matchup.team1_name}: ${player.name}`);
            }
        });
        currentMatchupData.team2.starters.forEach(player => {
            if (player.stats.fantasy_points === 0) {
                zeroPlayers.push(`${currentMatchupData.matchup.team2_name}: ${player.name}`);
            }
        });
        
        if (zeroPlayers.length > 0) {
            alert("Players with zero points:\n" + zeroPlayers.join("\n"));
        } else {
            alert("No players with zero points!");
        }
    }

    // Show scores file (placeholder)
    function showScoresFile() {
        alert("Scores file feature coming soon!");
    }
    

    // Parse URL to get year, week, and mode
    function parseUrl() {
        const path = window.location.pathname;
        const urlParams = new URLSearchParams(window.location.search);
        const matchupParam = urlParams.get('matchup');
        
        // Check if this is mock mode with week
        const mockMatch = path.match(/\/statfink\/mock\/(\d+)/);
        if (mockMatch) {
            return {
                isMock: true,
                week: parseInt(mockMatch[1]),
                matchup: matchupParam
            };
        }
        
        // Check if this is mock mode without week
        if (path.includes('/statfink/mock')) {
            return {
                isMock: true,
                matchup: matchupParam
            };
        }
        
        // Parse /statfink/year/week format
        const pathParts = path.split('/');
        if (pathParts.length >= 4 && pathParts[1] === 'statfink') {
            const year = parseInt(pathParts[2]);
            const week = parseInt(pathParts[3]);
            
            if (!isNaN(year) && !isNaN(week)) {
                return {
                    year: year,
                    week: week,
                    matchup: matchupParam,
                    isMock: false
                };
            }
        }
        
        // Fallback to query parameters for backwards compatibility
        return {
            year: urlParams.get('season'),
            week: urlParams.get('week'),
            matchup: matchupParam,
            isMock: false
        };
    }

    // Main initialization
    async function read_cont() {
        try {
            // Initialize fresh session on page load
            initializeSession();
            
            // Parse URL for year/week/mode
            const urlData = parseUrl();
            
            // Load league settings
            const settingsResponse = await fetch('/api/league/settings');
            const settings = await settingsResponse.json();
            
            if (settings.success) {
                // Use URL parameters if available, otherwise use current settings
                currentWeek = parseInt(urlData.week) || settings.data.current_week;
                currentSeason = parseInt(urlData.year) || settings.data.season_year;
                
                // Check for mock mode
                if (urlData.isMock) {
                    document.getElementById("fleague").innerHTML = `Week ${currentWeek}<br>Mock Mode`;
                    document.getElementById("updatemsg").innerHTML = "MOCK DATA - Testing Mode";
                    document.getElementById("updatemsg").style.color = "#ff6600";
                    document.getElementById("updatemsg").style.fontWeight = "bold";
                } else {
                    document.getElementById("fleague").innerHTML = `Week ${currentWeek}`;
                }
                
                // Update standings button visibility based on week
                updateStandingsButtonVisibility();
            }

            // Load matchups for current week
            await loadWeekMatchups();
            
            // Load NFL games
            await loadNFLGames();
            
            // Load all matchup details to populate remaining players count
            const matchupRows = document.getElementById("leaguetable").getElementsByTagName("tbody")[0].rows;
            const matchupIds = [];
            for (let i = 1; i < matchupRows.length; i++) {
                const row = matchupRows[i];
                const matchupId = row.getAttribute('data-matchup-id');
                if (matchupId) {
                    const id = parseInt(matchupId);
                    if (!matchupIds.includes(id)) {
                        matchupIds.push(id);
                    }
                }
            }
            
            // Load counts for all matchups in parallel (much faster)
            await Promise.all(matchupIds.map(matchupId => loadMatchupCountsOnly(matchupId)));
            
            // If specific matchup requested, load it again to display
            if (urlData.matchup) {
                currentMatchupId = parseInt(urlData.matchup);
                await loadMatchup(currentMatchupId);
            } else if (matchupIds.length > 0) {
                // Load first matchup by default
                currentMatchupId = matchupIds[0];
                await loadMatchup(currentMatchupId);
            }

            // Start refresh interval (30 seconds)
            startAutoRefresh(urlData.isMock);
            
        } catch (error) {
            console.error('Error initializing:', error);
            document.getElementById("fleague").textContent = "Error loading league data";
        }
    }

    // Load all matchups for the week
    async function loadWeekMatchups() {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock/${currentWeek}/${currentSeason}`
                : `/api/matchups/${currentWeek}/${currentSeason}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                // Save scores and get deltas
                const scoreData = saveTeamScores(data.data);
                
                const tbody = document.getElementById("leaguetable").getElementsByTagName("tbody")[0];
                
                // Keep the header row
                while (tbody.rows.length > 1) {
                    tbody.deleteRow(1);
                }
                
                // Add matchup rows in original format
                data.data.forEach((matchup, index) => {
                    // Team 1 row
                    const row1 = tbody.insertRow(-1);
                    row1.className = index % 2 ? "matchuprow2" : "matchuprow1";
                    row1.id = `lm${index}r0`;
                    row1.setAttribute('data-matchup-id', matchup.matchup_id);
                    row1.setAttribute('data-team', 'team1');
                    row1.onclick = () => selectMatchup(matchup.matchup_id);
                    row1.onmouseover = matchupmouseover;
                    row1.onmouseout = matchupmouseout;
                    
                    const team1Cell = row1.insertCell(0);
                    // Use cached count if available, otherwise don't show count
                    const team1Remaining = remainingPlayersCache[`${matchup.matchup_id}_team1`];
                    team1Cell.textContent = team1Remaining !== undefined 
                        ? `${matchup.team1_owner} (${team1Remaining})`
                        : matchup.team1_owner;
                    team1Cell.nowrap = true;
                    
                    const score1Cell = row1.insertCell(1);
                    const matchupScoreData = scoreData?.matchups?.[matchup.matchup_id];
                    // Check global deltas first, then local
                    const globalTeam1Delta = globalDeltas.teams[`${matchup.matchup_id}_team1`];
                    const globalTeam1Within30 = globalTeam1Delta && (Date.now() - globalTeam1Delta.timestamp <= 30000);
                    const team1Delta = globalTeam1Within30 ? globalTeam1Delta.delta : (matchupScoreData?.team1_delta || 0);
                    const team1Changed = globalTeam1Within30 || (matchupScoreData?.team1_lastChanged && 
                        (Date.now() - matchupScoreData.team1_lastChanged <= 30 * 1000));
                    
                    if (team1Changed && Math.abs(team1Delta) > 0.01) {
                        score1Cell.innerHTML = `<span class="score-delta">${team1Delta > 0 ? '+' : ''}${team1Delta.toFixed(2)}</span> ${matchup.team1_points.toFixed(2)}`;
                        score1Cell.className = "fanpts score-changed";
                    } else {
                        score1Cell.textContent = matchup.team1_points.toFixed(2);
                        score1Cell.className = "fanpts";
                    }
                    score1Cell.align = "right";
                    score1Cell.nowrap = true;
                    
                    // Team 2 row
                    const row2 = tbody.insertRow(-1);
                    row2.className = index % 2 ? "matchuprow2" : "matchuprow1";
                    row2.id = `lm${index}r1`;
                    row2.setAttribute('data-matchup-id', matchup.matchup_id);
                    row2.setAttribute('data-team', 'team2');
                    row2.onclick = () => selectMatchup(matchup.matchup_id);
                    row2.onmouseover = matchupmouseover;
                    row2.onmouseout = matchupmouseout;
                    
                    const team2Cell = row2.insertCell(0);
                    // Use cached count if available, otherwise don't show count
                    const team2Remaining = remainingPlayersCache[`${matchup.matchup_id}_team2`];
                    team2Cell.textContent = team2Remaining !== undefined 
                        ? `${matchup.team2_owner} (${team2Remaining})`
                        : matchup.team2_owner;
                    team2Cell.nowrap = true;
                    
                    const score2Cell = row2.insertCell(1);
                    // Check global deltas first, then local
                    const globalTeam2Delta = globalDeltas.teams[`${matchup.matchup_id}_team2`];
                    const globalTeam2Within30 = globalTeam2Delta && (Date.now() - globalTeam2Delta.timestamp <= 30000);
                    const team2Delta = globalTeam2Within30 ? globalTeam2Delta.delta : (matchupScoreData?.team2_delta || 0);
                    const team2Changed = globalTeam2Within30 || (matchupScoreData?.team2_lastChanged && 
                        (Date.now() - matchupScoreData.team2_lastChanged <= 30 * 1000));
                    
                    if (team2Changed && Math.abs(team2Delta) > 0.01) {
                        score2Cell.innerHTML = `<span class="score-delta">${team2Delta > 0 ? '+' : ''}${team2Delta.toFixed(2)}</span> ${matchup.team2_points.toFixed(2)}`;
                        score2Cell.className = "fanpts score-changed";
                    } else {
                        score2Cell.textContent = matchup.team2_points.toFixed(2);
                        score2Cell.className = "fanpts";
                    }
                    score2Cell.align = "right";
                    score2Cell.nowrap = true;
                    
                    // Only set default matchup if none is currently selected
                    if (!currentMatchupId && index === 0) {
                        currentMatchupId = matchup.matchup_id;
                    }
                });
                
                updateLastUpdate();
                
                // Apply the appropriate background class to the logo footer
                const logoFooter = document.querySelector('.logofooter');
                if (logoFooter && data.data.length > 0) {
                    // The last matchup row determines the background pattern
                    const lastMatchupIndex = data.data.length - 1;
                    const bgClass = lastMatchupIndex % 2 ? 'matchuprow1' : 'matchuprow2';
                    logoFooter.className = 'logofooter ' + bgClass;
                }
                
                // No longer need to load scoring totals - backend provides them
            }
        } catch (error) {
            console.error('Error loading matchups:', error);
        }
    }

    // Select and load a specific matchup
    async function selectMatchup(matchupId) {
        currentMatchupId = matchupId;
        await loadMatchup(matchupId);
        
        // Update browser URL to reflect current matchup
        updateUrlWithMatchup(matchupId);
    }
    
    // Update browser URL with current matchup
    function updateUrlWithMatchup(matchupId) {
        const currentPath = window.location.pathname;
        const isMockMode = currentPath.includes('/statfink/mock');
        
        let newUrl;
        if (isMockMode) {
            newUrl = `/statfink/mock/${currentWeek}?matchup=${matchupId}`;
        } else {
            newUrl = `/statfink/${currentSeason}/${currentWeek}?matchup=${matchupId}`;
        }
        
        // Update URL without reloading the page
        history.pushState({ matchupId: matchupId }, '', newUrl);
    }


    // Initialize fresh session (called on page load or refresh)
    function initializeSession() {
        sessionStats = {};
        sessionScores = {};
        sessionStartTime = Date.now();
        isFirstLoad = true;
        // Clear global deltas on page load/refresh
        globalDeltas = {
            players: {},
            teams: {}
        };
        console.log('Session initialized - all indicators cleared');
    }
    
    // Check if we should show an indicator (only for changes after session start)
    function shouldShowIndicator(changeTime) {
        if (!changeTime || isFirstLoad) return false;
        const timeSinceChange = Date.now() - changeTime;
        const timeSinceSessionStart = changeTime - sessionStartTime;
        // Only show if change happened after session started and within 30 seconds
        return timeSinceSessionStart > 0 && timeSinceChange <= 30000;
    }
    
    // Save team scores in memory only
    function saveTeamScores(matchups) {
        const previousData = sessionScores;
        const now = Date.now();
        
        const scoresToSave = {
            timestamp: now,
            matchups: {}
        };
        
        matchups.forEach(matchup => {
            const prevMatchup = previousData?.matchups?.[matchup.matchup_id];
            
            scoresToSave.matchups[matchup.matchup_id] = {
                team1_points: matchup.team1_points,
                team2_points: matchup.team2_points,
                team1_delta: 0,
                team2_delta: 0,
                team1_lastChanged: null,
                team2_lastChanged: null
            };
            
            // Only calculate deltas if not first load and previous data exists
            if (!isFirstLoad && prevMatchup) {
                const team1Delta = matchup.team1_points - prevMatchup.team1_points;
                const team2Delta = matchup.team2_points - prevMatchup.team2_points;
                
                if (Math.abs(team1Delta) > 0.01) {
                    scoresToSave.matchups[matchup.matchup_id].team1_delta = team1Delta;
                    scoresToSave.matchups[matchup.matchup_id].team1_lastChanged = now;
                    // Store in global deltas
                    globalDeltas.teams[`${matchup.matchup_id}_team1`] = {
                        delta: team1Delta,
                        timestamp: now
                    };
                } else if (shouldShowIndicator(prevMatchup.team1_lastChanged)) {
                    // Keep showing delta if still within 30-second window
                    scoresToSave.matchups[matchup.matchup_id].team1_delta = prevMatchup.team1_delta;
                    scoresToSave.matchups[matchup.matchup_id].team1_lastChanged = prevMatchup.team1_lastChanged;
                }
                
                if (Math.abs(team2Delta) > 0.01) {
                    scoresToSave.matchups[matchup.matchup_id].team2_delta = team2Delta;
                    scoresToSave.matchups[matchup.matchup_id].team2_lastChanged = now;
                    // Store in global deltas
                    globalDeltas.teams[`${matchup.matchup_id}_team2`] = {
                        delta: team2Delta,
                        timestamp: now
                    };
                } else if (shouldShowIndicator(prevMatchup.team2_lastChanged)) {
                    // Keep showing delta if still within 30-second window
                    scoresToSave.matchups[matchup.matchup_id].team2_delta = prevMatchup.team2_delta;
                    scoresToSave.matchups[matchup.matchup_id].team2_lastChanged = prevMatchup.team2_lastChanged;
                }
            }
        });
        
        sessionScores = scoresToSave;
        return scoresToSave;
    }
    
    // Get team scores from memory
    function getTeamScores() {
        return sessionScores;
    }

    // Save current stats in memory only
    function saveCurrentStats(matchupId, data, changedStats) {
        if (!sessionStats[matchupId]) {
            sessionStats[matchupId] = {};
        }
        
        const previousData = getPreviousStats(matchupId);
        const now = Date.now();
        
        const statsToSave = {
            timestamp: now,
            team1: {},
            team2: {}
        };

        // Save team1 stats with change timestamps
        data.team1.starters.forEach(player => {
            const prevPlayer = previousData?.team1?.[player.player_id];
            const playerChanges = changedStats?.team1?.[player.player_id] || [];
            const playerDelta = changedStats?.deltas?.team1?.[player.player_id] || 0;
            
            statsToSave.team1[player.player_id] = {
                name: player.name,
                stats: player.stats || {},
                lastChanged: {},
                previousFantasyPoints: player.stats?.fantasy_points || 0,
                fantasyPointsDelta: 0,
                fantasyPointsLastChanged: null
            };
            
            // Only track changes if not first load
            if (!isFirstLoad) {
                // Track delta and last changed time for fantasy_points
                if (Math.abs(playerDelta) > 0.01) {
                    statsToSave.team1[player.player_id].fantasyPointsDelta = playerDelta;
                    statsToSave.team1[player.player_id].fantasyPointsLastChanged = now;
                    // Store in global deltas
                    globalDeltas.players[player.player_id] = {
                        delta: playerDelta,
                        timestamp: now,
                        changedStats: playerChanges
                    };
                } else if (shouldShowIndicator(prevPlayer?.fantasyPointsLastChanged)) {
                    // Keep showing delta if still within 30-second window
                    statsToSave.team1[player.player_id].fantasyPointsDelta = prevPlayer.fantasyPointsDelta || 0;
                    statsToSave.team1[player.player_id].fantasyPointsLastChanged = prevPlayer.fantasyPointsLastChanged;
                    statsToSave.team1[player.player_id].previousFantasyPoints = player.stats?.fantasy_points || 0;
                }
                
                // Track when each stat last changed
                if (player.stats) {
                    Object.keys(player.stats).forEach(stat => {
                        if (playerChanges.includes(stat)) {
                            // This stat just changed
                            statsToSave.team1[player.player_id].lastChanged[stat] = now;
                            // Update global deltas with changed stats
                            if (!globalDeltas.players[player.player_id]) {
                                globalDeltas.players[player.player_id] = {
                                    delta: 0,
                                    timestamp: now,
                                    changedStats: []
                                };
                            }
                            if (!globalDeltas.players[player.player_id].changedStats.includes(stat)) {
                                globalDeltas.players[player.player_id].changedStats.push(stat);
                            }
                            globalDeltas.players[player.player_id].timestamp = now;
                        } else if (shouldShowIndicator(prevPlayer?.lastChanged?.[stat])) {
                            // Keep showing as changed if still within 30-second window
                            statsToSave.team1[player.player_id].lastChanged[stat] = prevPlayer.lastChanged[stat];
                        }
                    });
                }
            }
        });

        // Save team2 stats with change timestamps
        data.team2.starters.forEach(player => {
            const prevPlayer = previousData?.team2?.[player.player_id];
            const playerChanges = changedStats?.team2?.[player.player_id] || [];
            const playerDelta = changedStats?.deltas?.team2?.[player.player_id] || 0;
            
            statsToSave.team2[player.player_id] = {
                name: player.name,
                stats: player.stats || {},
                lastChanged: {},
                previousFantasyPoints: player.stats?.fantasy_points || 0,
                fantasyPointsDelta: 0,
                fantasyPointsLastChanged: null
            };
            
            // Only track changes if not first load
            if (!isFirstLoad) {
                // Track delta and last changed time for fantasy_points
                if (Math.abs(playerDelta) > 0.01) {
                    statsToSave.team2[player.player_id].fantasyPointsDelta = playerDelta;
                    statsToSave.team2[player.player_id].fantasyPointsLastChanged = now;
                    // Store in global deltas
                    globalDeltas.players[player.player_id] = {
                        delta: playerDelta,
                        timestamp: now,
                        changedStats: playerChanges
                    };
                } else if (shouldShowIndicator(prevPlayer?.fantasyPointsLastChanged)) {
                    // Keep showing delta if still within 30-second window
                    statsToSave.team2[player.player_id].fantasyPointsDelta = prevPlayer.fantasyPointsDelta || 0;
                    statsToSave.team2[player.player_id].fantasyPointsLastChanged = prevPlayer.fantasyPointsLastChanged;
                    statsToSave.team2[player.player_id].previousFantasyPoints = player.stats?.fantasy_points || 0;
                }
                
                // Track when each stat last changed
                if (player.stats) {
                    Object.keys(player.stats).forEach(stat => {
                        if (playerChanges.includes(stat)) {
                            // This stat just changed
                            statsToSave.team2[player.player_id].lastChanged[stat] = now;
                            // Update global deltas with changed stats
                            if (!globalDeltas.players[player.player_id]) {
                                globalDeltas.players[player.player_id] = {
                                    delta: 0,
                                    timestamp: now,
                                    changedStats: []
                                };
                            }
                            if (!globalDeltas.players[player.player_id].changedStats.includes(stat)) {
                                globalDeltas.players[player.player_id].changedStats.push(stat);
                            }
                            globalDeltas.players[player.player_id].timestamp = now;
                        } else if (shouldShowIndicator(prevPlayer?.lastChanged?.[stat])) {
                            // Keep showing as changed if still within 30-second window
                            statsToSave.team2[player.player_id].lastChanged[stat] = prevPlayer.lastChanged[stat];
                        }
                    });
                }
            }
        });

        sessionStats[matchupId] = statsToSave;
    }

    // Get previous stats from memory
    function getPreviousStats(matchupId) {
        return sessionStats[matchupId] || null;
    }

    // Compare stats and return changed players (with 30-second window) and deltas
    function compareStats(currentData, previousStats) {
        // If first load or no previous stats, return empty (nothing is "changed" on first load)
        if (isFirstLoad || !previousStats || !previousStats.timestamp) {
            return { team1: {}, team2: {}, deltas: { team1: {}, team2: {} } };
        }

        const changes = { team1: {}, team2: {} };
        const deltas = { team1: {}, team2: {} };
        const now = Date.now();

        // Compare team1
        currentData.team1.starters.forEach(player => {
            const prevPlayer = previousStats.team1[player.player_id];
            if (prevPlayer && prevPlayer.stats && player.stats) {
                const changedStats = [];
                
                // Calculate fantasy_points delta
                const currentPoints = player.stats.fantasy_points || 0;
                const previousPoints = prevPlayer.previousFantasyPoints || 0;
                const delta = currentPoints - previousPoints;
                
                if (Math.abs(delta) > 0.01) {
                    // New change detected
                    deltas.team1[player.player_id] = delta;
                } else if (shouldShowIndicator(prevPlayer.fantasyPointsLastChanged)) {
                    // Still within 30-second window - preserve delta
                    deltas.team1[player.player_id] = prevPlayer.fantasyPointsDelta || 0;
                }
                
                // Only compare stats that exist in both previous and current
                Object.keys(player.stats).forEach(stat => {
                    const currentValue = player.stats[stat];
                    const previousValue = prevPlayer.stats[stat];
                    
                    // Check if value changed
                    if (previousValue !== undefined && currentValue !== previousValue) {
                        // Value just changed - mark as bold
                        changedStats.push(stat);
                    } else if (shouldShowIndicator(prevPlayer.lastChanged?.[stat])) {
                        // Still within 30-second window - keep bold
                        changedStats.push(stat);
                    }
                    // If > 30 seconds, don't add to changedStats (unbold)
                });
                
                if (changedStats.length > 0) {
                    changes.team1[player.player_id] = changedStats;
                }
            }
        });

        // Compare team2
        currentData.team2.starters.forEach(player => {
            const prevPlayer = previousStats.team2[player.player_id];
            if (prevPlayer && prevPlayer.stats && player.stats) {
                const changedStats = [];
                
                // Calculate fantasy_points delta
                const currentPoints = player.stats.fantasy_points || 0;
                const previousPoints = prevPlayer.previousFantasyPoints || 0;
                const delta = currentPoints - previousPoints;
                
                if (Math.abs(delta) > 0.01) {
                    // New change detected
                    deltas.team2[player.player_id] = delta;
                } else if (shouldShowIndicator(prevPlayer.fantasyPointsLastChanged)) {
                    // Still within 30-second window - preserve delta
                    deltas.team2[player.player_id] = prevPlayer.fantasyPointsDelta || 0;
                }
                
                // Only compare stats that exist in both previous and current
                Object.keys(player.stats).forEach(stat => {
                    const currentValue = player.stats[stat];
                    const previousValue = prevPlayer.stats[stat];
                    
                    // Check if value changed
                    if (previousValue !== undefined && currentValue !== previousValue) {
                        // Value just changed - mark as bold
                        changedStats.push(stat);
                    } else if (shouldShowIndicator(prevPlayer.lastChanged?.[stat])) {
                        // Still within 30-second window - keep bold
                        changedStats.push(stat);
                    }
                    // If > 30 seconds, don't add to changedStats (unbold)
                });
                
                if (changedStats.length > 0) {
                    changes.team2[player.player_id] = changedStats;
                }
            }
        });

        return { ...changes, deltas };
    }

    // Load matchup data only for counting remaining players (without displaying)
    async function loadMatchupCountsOnly(matchupId) {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock-game/${matchupId}?week=${currentWeek}&season=${currentSeason}`
                : `/api/matchups/game/${matchupId}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                const matchup = data.data.matchup;
                
                // Calculate players not started yet (including in-progress games)
                const team1Remaining = data.data.team1.starters.filter(p => 
                    p.game_status !== 'Final' && p.game_status !== undefined
                ).length;
                const team2Remaining = data.data.team2.starters.filter(p => 
                    p.game_status !== 'Final' && p.game_status !== undefined
                ).length;
                
                // Cache the remaining players count for the left bar
                remainingPlayersCache[`${matchup.matchup_id}_team1`] = team1Remaining;
                remainingPlayersCache[`${matchup.matchup_id}_team2`] = team2Remaining;
                
                // Update the left bar display for this matchup
                updateLeftBarMatchup(matchup.matchup_id, matchup.team1_owner, team1Remaining, matchup.team2_owner, team2Remaining);
            }
        } catch (error) {
            console.error('Error loading matchup counts:', error);
        }
    }

    // Load matchup details
    async function loadMatchup(matchupId) {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock-game/${matchupId}?week=${currentWeek}&season=${currentSeason}`
                : `/api/matchups/game/${matchupId}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                // Get previous stats before saving new ones
                const previousStats = getPreviousStats(matchupId);
                
                // Compare stats to find changes
                const changedStats = compareStats(data.data, previousStats);
                
                
                // Save current stats for next comparison
                saveCurrentStats(matchupId, data.data, changedStats);
                
                currentMatchupData = data.data;
                displayMatchup(data.data, changedStats);
                updateLastUpdate();
                
                // After first successful load, no longer first load
                if (isFirstLoad) {
                    isFirstLoad = false;
                    console.log('First data load complete - future changes will show indicators');
                }
            }
        } catch (error) {
            console.error('Error loading matchup:', error);
        }
    }

    // Update left bar matchup display with remaining players count
    function updateLeftBarMatchup(matchupId, team1Owner, team1Remaining, team2Owner, team2Remaining) {
        // Find the matchup rows in the left bar using data attributes
        const tbody = document.getElementById("leaguetable").getElementsByTagName("tbody")[0];
        const rows = tbody.querySelectorAll(`tr[data-matchup-id="${matchupId}"]`);
        
        rows.forEach(row => {
            const team = row.getAttribute('data-team');
            const cell = row.cells[0];
            
            if (team === 'team1') {
                cell.textContent = `${team1Owner} (${team1Remaining})`;
            } else if (team === 'team2') {
                cell.textContent = `${team2Owner} (${team2Remaining})`;
            }
        });
    }

    // Display matchup data
    function displayMatchup(data, changedStats = { team1: {}, team2: {}, deltas: { team1: {}, team2: {} } }) {
        const matchup = data.matchup;
        
        // Calculate players not started yet (including in-progress games)
        const team1Remaining = data.team1.starters.filter(p => 
            p.game_status !== 'Final' && p.game_status !== undefined
        ).length;
        const team2Remaining = data.team2.starters.filter(p => 
            p.game_status !== 'Final' && p.game_status !== undefined
        ).length;
        
        // Update team headers
        document.getElementById("fteam0").innerHTML = `${matchup.team1_owner} (${team1Remaining})`;
        document.getElementById("fteam1").innerHTML = `${matchup.team2_owner} (${team2Remaining})`;
        
        // Cache the remaining players count for the left bar
        remainingPlayersCache[`${matchup.matchup_id}_team1`] = team1Remaining;
        remainingPlayersCache[`${matchup.matchup_id}_team2`] = team2Remaining;
        
        // Update the left bar display for this matchup
        updateLeftBarMatchup(matchup.matchup_id, matchup.team1_owner, team1Remaining, matchup.team2_owner, team2Remaining);
        
        // Build team tables and get scoring totals
        const team1ScoringTotal = displayTeamRoster("team0", data.team1.starters, matchup.team1_name, changedStats.team1, changedStats.deltas?.team1 || {});
        const team2ScoringTotal = displayTeamRoster("team1", data.team2.starters, matchup.team2_name, changedStats.team2, changedStats.deltas?.team2 || {});
    }

    // This function is no longer needed - backend provides scoring totals
    async function loadAllMatchupScoringTotals_DEPRECATED(matchups) {
        try {
            // Process each matchup to calculate scoring totals
            for (const matchup of matchups) {
                // Skip if already calculated
                if (scoringTotalsCache[matchup.matchup_id]) {
                    updateMatchupScoreDisplay(matchup.matchup_id, 
                        scoringTotalsCache[matchup.matchup_id].team1,
                        scoringTotalsCache[matchup.matchup_id].team2);
                    continue;
                }
                
                // Fetch matchup details
                const isMockMode = window.location.pathname.includes('/statfink/mock');
                const apiUrl = isMockMode 
                    ? `/api/matchups/mock-game/${matchup.matchup_id}?week=${currentWeek}&season=${currentSeason}`
                    : `/api/matchups/game/${matchup.matchup_id}`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                if (data.success) {
                    // Calculate scoring players for both teams
                    const team1Scoring = calculateScoringPlayers(data.data.team1.starters);
                    const team2Scoring = calculateScoringPlayers(data.data.team2.starters);
                    
                    // Calculate totals
                    let team1Total = 0;
                    let team2Total = 0;
                    
                    data.data.team1.starters.forEach(player => {
                        if (team1Scoring.has(player)) {
                            team1Total += player.stats ? player.stats.fantasy_points : 0;
                        }
                    });
                    
                    data.data.team2.starters.forEach(player => {
                        if (team2Scoring.has(player)) {
                            team2Total += player.stats ? player.stats.fantasy_points : 0;
                        }
                    });
                    
                    // Cache and update display
                    scoringTotalsCache[matchup.matchup_id] = {
                        team1: team1Total,
                        team2: team2Total
                    };
                    
                    updateMatchupScoreDisplay(matchup.matchup_id, team1Total, team2Total);
                }
                
                // Small delay to avoid overwhelming the server
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        } catch (error) {
            console.error('Error loading scoring totals:', error);
        }
    }

    // Update matchup score display in the left panel
    function updateMatchupScoreDisplay(matchupId, team1Score, team2Score) {
        // Find the matchup rows
        const rows = document.getElementById("leaguetable").getElementsByTagName("tbody")[0].rows;
        
        for (let i = 1; i < rows.length; i += 2) {
            const row1 = rows[i];
            const row2 = rows[i + 1];
            
            if (row1 && row1.onclick) {
                // Extract matchup ID from the onclick handler
                const onclickStr = row1.onclick.toString();
                if (onclickStr.includes(`selectMatchup(${matchupId})`)) {
                    // Update scores
                    const score1Cell = row1.cells[1];
                    const score2Cell = row2.cells[1];
                    
                    if (score1Cell) {
                        score1Cell.textContent = team1Score.toFixed(2);
                        score1Cell.style.fontWeight = 'bold';
                        score1Cell.style.color = '#000'; // Black for final scoring total
                        score1Cell.title = "Scoring players total";
                    }
                    if (score2Cell) {
                        score2Cell.textContent = team2Score.toFixed(2);
                        score2Cell.style.fontWeight = 'bold';
                        score2Cell.style.color = '#000'; // Black for final scoring total
                        score2Cell.title = "Scoring players total";
                    }
                    break;
                }
            }
        }
    }

    // This function is no longer needed - backend provides is_scoring flag
    function calculateScoringPlayers_DEPRECATED(starters) {
        // Create a Set to store scoring players
        const scoringPlayers = new Set();
        
        // Sort players by fantasy points (highest first)
        const sortedPlayers = [...starters].sort((a, b) => {
            const pointsA = a.stats ? a.stats.fantasy_points : 0;
            const pointsB = b.stats ? b.stats.fantasy_points : 0;
            return pointsB - pointsA;
        });
        
        // Track how many of each position we've selected
        const positionCounts = {
            QB: 0,
            RB: 0,
            WR_TE: 0,  // Combined WR/TE
            K: 0,
            DST: 0,
            BONUS: 0
        };
        
        // Position limits based on scoring rules
        const limits = {
            QB: 1,
            RB: 4,
            WR_TE: 4,
            K: 1,
            DST: 2,  // This will be handled separately (best points/yards allowed)
            BONUS: 1
        };
        
        // First pass: Fill required position slots (skip players with 0 points)
        sortedPlayers.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            if (points === 0) return; // Skip players with 0 points
            
            const pos = player.position;
            
            if (pos === 'QB' && positionCounts.QB < limits.QB) {
                scoringPlayers.add(player);
                positionCounts.QB++;
            } else if (pos === 'RB' && positionCounts.RB < limits.RB) {
                scoringPlayers.add(player);
                positionCounts.RB++;
            } else if ((pos === 'WR' || pos === 'TE') && positionCounts.WR_TE < limits.WR_TE) {
                scoringPlayers.add(player);
                positionCounts.WR_TE++;
            } else if (pos === 'K' && positionCounts.K < limits.K) {
                scoringPlayers.add(player);
                positionCounts.K++;
            } else if ((pos === 'DST' || pos === 'DEF') && positionCounts.DST < limits.DST) {
                // For DST, we should ideally pick best points allowed and best yards allowed
                // For now, just take top 2 DST by fantasy points
                scoringPlayers.add(player);
                positionCounts.DST++;
            }
        });
        
        // Second pass: Fill bonus slots with highest scoring remaining players (skip 0 point players)
        sortedPlayers.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            if (points === 0) return; // Skip players with 0 points
            
            if (!scoringPlayers.has(player) && positionCounts.BONUS < limits.BONUS) {
                // Any position can be a bonus player
                scoringPlayers.add(player);
                positionCounts.BONUS++;
            }
        });
        
        return scoringPlayers;
    }

    // Display team roster
    function displayTeamRoster(tableId, starters, teamName, changedPlayers = {}, deltas = {}) {
        const table = document.getElementById(tableId);
        const tbody = table.getElementsByTagName("tbody")[0];
        
        // Clear existing rows except header
        while (tbody.rows.length > 1) {
            tbody.deleteRow(1);
        }
        
        // Add header row
        const headerRow = tbody.insertRow(-1);
        headerRow.className = "pointsrow";
        headerRow.innerHTML = `
            <td>Pos</td>
            <td>Player</td>
            <td class="opp">Opp</td>
            <td align="center" nowrap>Game Status</td>
            <td align="right">FanPts</td>
        `;
        
        let totalPoints = 0;
        let scoringTotalPoints = 0;
        let rowIndex = 0;
        
        starters.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            totalPoints += points;
            
            // Check if this player is one of the scoring players (from backend)
            const isScoring = player.is_scoring === true;
            if (isScoring) {
                scoringTotalPoints += points;
            }
            
            // Check if any stats changed for this player (from global deltas first, then local)
            const globalPlayerInfo = globalDeltas.players[player.player_id];
            const globalChangedStats = (globalPlayerInfo && (Date.now() - globalPlayerInfo.timestamp <= 30000)) 
                ? globalPlayerInfo.changedStats : [];
            const playerChangedStats = globalChangedStats.length > 0 ? globalChangedStats : (changedPlayers[player.player_id] || []);
            
            // Player row
            const row = tbody.insertRow(-1);
            row.className = rowIndex % 2 ? "playerrow2" : "playerrow1";
            row.id = `t${tableId.slice(-1)}r${rowIndex}`;
            
            // Format defense names consistently
            let basePlayerName = player.name;
            // Remove suffixes like Jr., Sr., III, etc.
            basePlayerName = basePlayerName.replace(/\s+(Jr\.?|Sr\.?|III|II|IV|V)$/i, '');
            if (player.position === 'DEF' || player.position === 'DST') {
                // For defenses, just use the team abbreviation
                basePlayerName = player.team;
            } else {
                // For regular players, format long names
                basePlayerName = formatPlayerName(basePlayerName);
            }
            
            // Add asterisk if player is scoring AND has points (no bold for player name)
            const playerName = (isScoring && points > 0) ? `*${basePlayerName}` : basePlayerName;
            
            // Get the game status before building the HTML
            const gameStatus = getPlayerGameStatus(player);
            
            // Get the stats display before building the HTML
            const statsDisplay = formatPlayerStatsCompact(player.position, player.stats, playerChangedStats);
            
            // Check if this player has a score delta from global deltas
            const globalPlayerDelta = globalDeltas.players[player.player_id];
            const isWithin30Seconds = globalPlayerDelta && (Date.now() - globalPlayerDelta.timestamp <= 30000);
            const delta = (isWithin30Seconds ? globalPlayerDelta.delta : 0) || deltas[player.player_id] || 0;
            const hasScoreDelta = Math.abs(delta) > 0.01;
            
            // Add stat-changed class to points if fantasy_points changed OR if there's a delta
            const pointsClass = (playerChangedStats.includes('fantasy_points') || hasScoreDelta) ? 'points fanpts score-changed' : 'points fanpts';
            
            // Build the points display with delta if there's a delta to show
            let pointsDisplay = points.toFixed(2);
            if (hasScoreDelta) {
                pointsDisplay = `<span class="score-delta">${delta > 0 ? '+' : ''}${delta.toFixed(2)}</span> ${points.toFixed(2)}`;
            }
            
            // For defenses, don't show team code after name since it's redundant
            const displayName = player.position === 'DEF' ? playerName : `${playerName} &nbsp;&nbsp;${player.team}`;
            
            // Keep original name (without suffix) for tooltip
            const originalName = player.name.replace(/\s+(Jr\.?|Sr\.?|III|II|IV|V)$/i, '');
            
            // Check if game is currently in progress (anything that's not Final or Scheduled)
            const isGameInProgress = player.game_status && 
                player.game_status !== 'Final' && 
                player.game_status !== 'Scheduled';
            
            row.innerHTML = `
                <td class="position position-${player.position}">${player.position}</td>
                <td class="${isGameInProgress ? 'playername playernameinprogress' : 'playername'}" nowrap title="${originalName}">${displayName}</td>
                <td class="opp">${player.opp || ''}</td>
                <td class="status" align="center" nowrap>${gameStatus}</td>
                <td class="${pointsClass}" align="right" nowrap>${pointsDisplay}</td>
            `;
            
            // Add stats row like reference site
            if (statsDisplay) {
                const statsRow = tbody.insertRow(-1);
                statsRow.className = row.className; // Use same class as main row
                statsRow.id = `t${tableId.slice(-1)}r${rowIndex}combstat`;
                const statsCell = statsRow.insertCell(0);
                statsCell.colSpan = 5;
                statsCell.style.fontSize = 'smaller';
                statsCell.innerHTML = statsDisplay;
            }
            
            rowIndex++;
        });
        
        // Add total row (show scoring total, not all players total)
        const totalRow = tbody.insertRow(-1);
        totalRow.className = "totalsrow";
        totalRow.innerHTML = `
            <td colspan="4" class="fanptsbig">Net Points</td>
            <td class="fanptsbig" align="right">${scoringTotalPoints.toFixed(2)}</td>
        `;
        
        return scoringTotalPoints;
    }

    // Format player stats based on position
    function formatPlayerStats(position, stats) {
        if (!stats) return 'No stats available';
        
        let details = [];
        
        switch(position) {
            case 'QB':
                if (stats.passing_yards > 0) details.push(`${stats.passing_yards} pass yds`);
                if (stats.passing_tds > 0) details.push(`${stats.passing_tds} pass TD`);
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} rush yds`);
                if (stats.rushing_tds > 0) details.push(`${stats.rushing_tds} rush TD`);
                if (stats.interceptions > 0) details.push(`${stats.interceptions} INT`);
                break;
            case 'RB':
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} rush yds`);
                if (stats.rushing_tds > 0) details.push(`${stats.rushing_tds} rush TD`);
                if (stats.receptions > 0) details.push(`${stats.receptions} rec`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} rec yds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} rec TD`);
                break;
            case 'WR':
            case 'TE':
                if (stats.receptions > 0) details.push(`${stats.receptions} rec`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} rec yds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} rec TD`);
                break;
            case 'K':
                if (stats.field_goals_made > 0) details.push(`${stats.field_goals_made}/${stats.field_goals_attempted} FG`);
                if (stats.extra_points_made > 0) details.push(`${stats.extra_points_made}/${stats.extra_points_attempted} XP`);
                break;
            case 'DST':
            case 'DEF':
                if (stats.sacks > 0) details.push(`${stats.sacks} sacks`);
                if (stats.def_interceptions > 0) details.push(`${stats.def_interceptions} INT`);
                if (stats.fumbles_recovered > 0) details.push(`${stats.fumbles_recovered} FR`);
                if (stats.def_touchdowns > 0) details.push(`${stats.def_touchdowns} TD`);
                if (stats.points_allowed !== undefined) details.push(`${stats.points_allowed} PtsAllw`);
                if (stats.yards_allowed !== undefined) details.push(`${stats.yards_allowed} YdsAllw`);
                break;
        }
        
        return details.join(', ') || 'No stats';
    }

    // Get player game status (show time if not started, game status if in progress, Final if complete)
    function getPlayerGameStatus(player) {
        if (player.game_status === 'Scheduled' && player.game_time) {
            // Convert ET to PST, include epoch time if available for day of week
            return convertToPST(player.game_time, player.game_time_epoch);
        } else if (player.game_status === 'Halftime') {
            // Show "Halftime" for halftime
            return 'Halftime';
        } else if (player.game_status === 'InProgress' && player.game_time) {
            // Handle old format where game_status is 'InProgress' and time is in game_time
            return player.game_time;
        } else if (player.game_status && player.game_status !== 'Scheduled') {
            // For live games, show the actual game status (e.g. "Q2 12:45", "Final", etc.)
            return player.game_status;
        }
        // If no game_status, check if player has stats to determine if game was played
        if (!player.stats || Object.keys(player.stats || {}).length === 0) {
            return player.game_time || 'TBD';
        }
        return player.game_status || 'Final';
    }
    
    // Convert ET time to PST
    function convertToPST(etTime, epochTime = null) {
        // Handle both "4:25p" and "4:25 PM ET" formats
        let match = etTime.match(/(\d+):(\d+) (AM|PM) ET/);
        if (!match) {
            // Try simpler format like "4:25p" or "1:00p"
            match = etTime.match(/(\d+):(\d+)([ap])/i);
            if (!match) return etTime;
            // Convert 'p' to 'PM' and 'a' to 'AM'
            match[3] = match[3].toUpperCase() === 'P' ? 'PM' : 'AM';
        }
        
        let hours = parseInt(match[1]);
        const minutes = match[2];
        const period = match[3];
        
        // Convert to 24-hour format
        if (period === 'PM' && hours !== 12) hours += 12;
        if (period === 'AM' && hours === 12) hours = 0;
        
        // Subtract 3 hours for PST
        hours -= 3;
        
        // Handle negative hours
        if (hours < 0) {
            hours += 12;
            // If it was PM, it becomes AM and vice versa
            const newPeriod = period === 'PM' ? 'AM' : 'PM';
            const timeStr = `${hours === 0 ? 12 : hours}:${minutes} ${newPeriod}`;
            
            // If we have epoch time, add day of week
            if (epochTime) {
                const date = new Date(epochTime * 1000);
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayName = days[date.getDay()];
                return `${dayName} ${timeStr}`;
            }
            return timeStr;
        }
        
        // Convert back to 12-hour format
        const newPeriod = hours >= 12 ? 'PM' : 'AM';
        if (hours > 12) hours -= 12;
        if (hours === 0) hours = 12;
        
        const timeStr = `${hours}:${minutes} ${newPeriod}`;
        
        // If we have epoch time, add day of week
        if (epochTime) {
            const date = new Date(epochTime * 1000);
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayName = days[date.getDay()];
            return `${dayName} ${timeStr}`;
        }
        
        return timeStr;
    }

    // Format player stats in compact form like original Statfink
    function formatPlayerStatsCompact(position, stats, changedStats = []) {
        if (!stats) return '0 Stats';
        
        let details = [];
        
        // Helper function to wrap entire stat phrase in bold span if changed
        const wrapIfChanged = (statPhrase, statNames) => {
            // Check if any of the stat names are in the changed list
            const isChanged = Array.isArray(statNames) 
                ? statNames.some(name => changedStats.includes(name))
                : changedStats.includes(statNames);
            
            if (isChanged) {
                return `<span class="stat-changed">${statPhrase}</span>`;
            }
            return statPhrase;
        };
        
        switch(position) {
            case 'QB':
                if ((stats.completions || 0) > 0) details.push(wrapIfChanged(`${stats.completions} Comp`, 'completions'));
                if ((stats.passing_attempts || 0) - (stats.completions || 0) > 0) details.push(wrapIfChanged(`${stats.passing_attempts - stats.completions} Inc`, 'passing_attempts'));
                if ((stats.passing_yards || 0) > 0) details.push(wrapIfChanged(`${stats.passing_yards} Pyds`, 'passing_yards'));
                if ((stats.rushing_yards || 0) > 0) details.push(wrapIfChanged(`${stats.rushing_yards} Rshyds`, 'rushing_yards'));
                if ((stats.passing_tds || 0) + (stats.rushing_tds || 0) > 0) {
                    const tds = (stats.passing_tds || 0) + (stats.rushing_tds || 0);
                    details.push(wrapIfChanged(`${tds} TDs`, ['passing_tds', 'rushing_tds']));
                }
                if ((stats.two_point_conversions_pass || 0) > 0) details.push(wrapIfChanged(`${stats.two_point_conversions_pass} 2PC`, 'two_point_conversions_pass'));
                break;
            case 'RB':
                if ((stats.rushing_yards || 0) > 0) details.push(wrapIfChanged(`${stats.rushing_yards} Rshyds`, 'rushing_yards'));
                if ((stats.receptions || 0) > 0) details.push(wrapIfChanged(`${stats.receptions} Recs`, 'receptions'));
                if ((stats.receiving_yards || 0) > 0) details.push(wrapIfChanged(`${stats.receiving_yards} Recyds`, 'receiving_yards'));
                if ((stats.rushing_tds || 0) + (stats.receiving_tds || 0) > 0) {
                    const tds = (stats.rushing_tds || 0) + (stats.receiving_tds || 0);
                    details.push(wrapIfChanged(`${tds} TDs`, ['rushing_tds', 'receiving_tds']));
                }
                if ((stats.two_point_conversions_run || 0) + (stats.two_point_conversions_rec || 0) > 0) {
                    const tpc = (stats.two_point_conversions_run || 0) + (stats.two_point_conversions_rec || 0);
                    details.push(wrapIfChanged(`${tpc} 2PC`, ['two_point_conversions_run', 'two_point_conversions_rec']));
                }
                break;
            case 'WR':
            case 'TE':
                if ((stats.receptions || 0) > 0) details.push(wrapIfChanged(`${stats.receptions} Recs`, 'receptions'));
                if ((stats.receiving_yards || 0) > 0) details.push(wrapIfChanged(`${stats.receiving_yards} Recyds`, 'receiving_yards'));
                if ((stats.receiving_tds || 0) > 0) details.push(wrapIfChanged(`${stats.receiving_tds} TDs`, 'receiving_tds'));
                if ((stats.two_point_conversions_rec || 0) > 0) details.push(wrapIfChanged(`${stats.two_point_conversions_rec} 2PC`, 'two_point_conversions_rec'));
                break;
            case 'K':
                if ((stats.field_goals_made || 0) > 0) details.push(wrapIfChanged(`${stats.field_goals_made} FG`, 'field_goals_made'));
                if ((stats.extra_points_made || 0) > 0) details.push(wrapIfChanged(`${stats.extra_points_made} XP`, 'extra_points_made'));
                break;
            case 'DST':
            case 'DEF':
                if ((stats.sacks || 0) > 0) details.push(wrapIfChanged(`${stats.sacks} Sck`, 'sacks'));
                if ((stats.def_interceptions || 0) > 0) details.push(wrapIfChanged(`${stats.def_interceptions} Int`, 'def_interceptions'));
                if ((stats.fumbles_recovered || 0) > 0) details.push(wrapIfChanged(`${stats.fumbles_recovered} FR`, 'fumbles_recovered'));
                // Calculate total defensive TDs from breakdown fields
                const defTDs = (stats.def_int_return_tds || 0) + (stats.def_fumble_return_tds || 0) + (stats.def_blocked_return_tds || 0);
                if (defTDs > 0) details.push(wrapIfChanged(`${defTDs} TD`, ['def_int_return_tds', 'def_fumble_return_tds', 'def_blocked_return_tds']));
                if ((stats.safeties || 0) > 0) details.push(wrapIfChanged(`${stats.safeties} Sfty`, 'safeties'));
                if (stats.points_allowed !== undefined) details.push(wrapIfChanged(`${stats.points_allowed} PtsAllw`, 'points_allowed'));
                if (stats.yards_allowed !== undefined) details.push(wrapIfChanged(`${stats.yards_allowed} YdsAllw`, 'yards_allowed'));
                break;
        }
        
        if (details.length === 0) {
            return '0 Stats';
        }
        
        return details.join(', ');
    }

    // Update last update time
    async function updateLastUpdate() {
        try {
            const response = await fetch('/api/league/sync-status');
            const data = await response.json();
            
            if (data.success && data.data.last_sync_time) {
                const syncTime = new Date(data.data.last_sync_time);
                document.getElementById("lastupdate").textContent = `Last Tank01 Sync: ${syncTime.toLocaleString()}`;
            } else {
                const now = new Date();
                document.getElementById("lastupdate").textContent = `Last Update: ${now.toLocaleTimeString()}`;
            }
        } catch (error) {
            console.error('Error fetching sync status:', error);
            const now = new Date();
            document.getElementById("lastupdate").textContent = `Last Update: ${now.toLocaleTimeString()}`;
        }
        
        // Update the message next to Options with current time
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
        });
        const dateString = now.toLocaleDateString('en-US', { 
            month: 'numeric', 
            day: 'numeric',
            year: '2-digit'
        });
        document.getElementById("updatemsg").textContent = `Updated ${dateString}, ${timeString}`;
        // Reset color to default (not orange) for regular updates
        document.getElementById("updatemsg").style.color = "#333";
        document.getElementById("updatemsg").style.fontWeight = "normal";
    }

    // Variables for auto-refresh
    var refreshInterval = null;
    var refreshCountdown = null;
    var secondsUntilRefresh = 30;
    var isMockMode = false;
    
    // Start auto-refresh
    function startAutoRefresh(mockMode) {
        isMockMode = mockMode;
        
        // Clear any existing intervals
        if (refreshInterval) clearInterval(refreshInterval);
        if (refreshCountdown) clearInterval(refreshCountdown);
        
        // Only start refresh if we have in-progress games (for mock mode)
        if (mockMode) {
            checkAndStartRefresh();
        } else {
            // For real mode, always refresh
            refreshInterval = setInterval(refreshData, 30000);
        }
    }
    
    // Check if mock mode has in-progress games
    async function checkAndStartRefresh() {
        try {
            const response = await fetch(`/api/nfl-games/mock/${currentWeek}/${currentSeason}`);
            const data = await response.json();
            
            if (data.success && data.data) {
                const hasActiveGames = data.data.some(game => 
                    game.status === 'InProgress' || game.status === 'Halftime'
                );
                
                if (hasActiveGames) {
                    // Start refresh and countdown
                    secondsUntilRefresh = 30;
                    updateRefreshCountdown();
                    refreshCountdown = setInterval(updateRefreshCountdown, 1000);
                    refreshInterval = setInterval(refreshData, 30000);
                } else {
                    // No active games, stop refreshing
                    document.getElementById("updatemsg").textContent = "All games complete";
                }
            }
        } catch (error) {
            console.error('Error checking game status:', error);
        }
    }
    
    // Update countdown display
    function updateRefreshCountdown() {
        secondsUntilRefresh--;
        if (secondsUntilRefresh <= 0) {
            secondsUntilRefresh = 30;
        }
        
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
        });
        
        if (isMockMode) {
            document.getElementById("updatemsg").innerHTML = `MOCK MODE - Next update in ${secondsUntilRefresh}s`;
            document.getElementById("updatemsg").style.color = "#ff6600";
            document.getElementById("updatemsg").style.fontWeight = "bold";
        } else {
            document.getElementById("updatemsg").textContent = `Updated ${timeString} - Next in ${secondsUntilRefresh}s`;
        }
    }
    
    // Refresh data
    async function refreshData() {
        // Store current matchup before refresh
        const preservedMatchupId = currentMatchupId;
        
        // For mock mode, simulate game progression
        if (isMockMode && currentWeek) {
            try {
                const progressResponse = await fetch(`/api/matchups/mock/simulate-update/${currentWeek}`, {
                    method: 'POST'
                });
                const progressData = await progressResponse.json();
                
                if (!progressData.hasActiveGames) {
                    // Stop refreshing if no more active games
                    if (refreshInterval) clearInterval(refreshInterval);
                    if (refreshCountdown) clearInterval(refreshCountdown);
                    document.getElementById("updatemsg").textContent = "All games complete";
                    document.getElementById("updatemsg").style.color = "#333";
                    document.getElementById("updatemsg").style.fontWeight = "normal";
                }
            } catch (error) {
                console.error('Error simulating game update:', error);
            }
        }
        
        // Refresh matchup list
        await loadWeekMatchups();
        
        // Restore the preserved matchup ID
        currentMatchupId = preservedMatchupId;
        
        // Refresh current matchup and NFL games
        if (currentMatchupId) {
            await loadMatchup(currentMatchupId);
            // Ensure URL stays in sync
            updateUrlWithMatchup(currentMatchupId);
        }
        await loadNFLGames();
        
        // Update last update time
        updateLastUpdate();
    }

    // Highlight NFL game on hover
    function highlightGame(cells, highlight) {
        cells.forEach(cell => {
            if (highlight) {
                // Store original classes
                cell.dataset.originalClass = cell.className;
                // Apply highlight classes
                if (cell.className.includes('pts')) {
                    cell.className = 'nflhlpts';
                } else if (cell.className.includes('status')) {
                    cell.className = 'nflhlstatus';
                } else {
                    cell.className = 'nflhl';
                }
            } else {
                // Restore original classes
                if (cell.dataset.originalClass) {
                    cell.className = cell.dataset.originalClass;
                }
            }
        });
    }
    
    // Load NFL games for the week
    async function loadNFLGames() {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/nfl-games/mock/${currentWeek}/${currentSeason}`
                : `/api/nfl-games/${currentWeek}/${currentSeason}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success && data.data.length > 0) {
                displayNFLGames(data.data);
            }
        } catch (error) {
            console.error('Error loading NFL games:', error);
        }
    }
    
    // Display NFL games in grid format
    function displayNFLGames(games) {
        const tbody = document.getElementById('nfltable').getElementsByTagName('tbody')[0];
        tbody.innerHTML = ''; // Clear existing content
        
        // Sort games by: Live games first, then upcoming (soonest first), then finished
        const sortedGames = [...games].sort((a, b) => {
            // Categorize games
            const isLiveA = a.status !== 'Final' && a.status !== 'Scheduled';
            const isLiveB = b.status !== 'Final' && b.status !== 'Scheduled';
            const isScheduledA = a.status === 'Scheduled';
            const isScheduledB = b.status === 'Scheduled';
            const isFinalA = a.status === 'Final';
            const isFinalB = b.status === 'Final';
            
            // Live games come first
            if (isLiveA && !isLiveB) return -1;
            if (!isLiveA && isLiveB) return 1;
            
            // Then scheduled games (sorted by time)
            if (isScheduledA && !isScheduledB) return -1;
            if (!isScheduledA && isScheduledB) return 1;
            
            // If both are scheduled, sort by epoch time (soonest first)
            if (isScheduledA && isScheduledB) {
                const timeA = a.game_time_epoch || 0;
                const timeB = b.game_time_epoch || 0;
                return timeA - timeB;
            }
            
            // Final games come last
            if (isFinalA && !isFinalB) return 1;
            if (!isFinalA && isFinalB) return -1;
            
            // Otherwise keep original order
            return 0;
        });
        
        // Group games into rows (4 games per row)
        const gamesPerRow = 4;
        const rows = [];
        
        for (let i = 0; i < sortedGames.length; i += gamesPerRow) {
            rows.push(sortedGames.slice(i, i + gamesPerRow));
        }
        
        // Create table rows with exact HTML structure
        rows.forEach((rowGames, rowIndex) => {
            // Create rows using exact HTML from reference
            const tr1 = document.createElement('tr');
            tr1.id = `nfl${rowIndex}r0`;
            
            const tr2 = document.createElement('tr');
            tr2.id = `nfl${rowIndex}r1`;
            
            const tr3 = document.createElement('tr');
            tr3.id = `nfl${rowIndex}rs`;
            
            // Process each game in this row
            rowGames.forEach((game, colIndex) => {
                const gameIndex = rowIndex * gamesPerRow + colIndex;
                
                // Create checkered pattern based on row and column position
                const isEven = (rowIndex + colIndex) % 2 === 0;
                const baseClass = isEven ? 'nfl1' : 'nfl2';
                const ptsClass = isEven ? 'nfl1pts' : 'nfl2pts';
                const statusClass = isEven ? 'nfl1status' : 'nfl2status';
                
                // Row 1: Away team and score
                const awayTeamCell = document.createElement('td');
                awayTeamCell.id = `g${gameIndex}nfl${rowIndex}r0c${colIndex * 2}`;
                awayTeamCell.className = baseClass;
                awayTeamCell.setAttribute('nowrap', '');
                awayTeamCell.title = game.status;
                awayTeamCell.textContent = game.away_team;
                
                const awayScoreCell = document.createElement('td');
                awayScoreCell.id = `g${gameIndex}nfl${rowIndex}r0c${colIndex * 2 + 1}p`;
                awayScoreCell.className = ptsClass;
                awayScoreCell.setAttribute('nowrap', '');
                awayScoreCell.align = 'right';
                awayScoreCell.title = game.status;
                awayScoreCell.textContent = game.status === 'Scheduled' ? '0' : game.away_score;
                
                tr1.appendChild(awayTeamCell);
                tr1.appendChild(awayScoreCell);
                
                // Row 2: Home team and score
                const homeTeamCell = document.createElement('td');
                homeTeamCell.id = `g${gameIndex}nfl${rowIndex}r1c${colIndex * 2}`;
                homeTeamCell.className = baseClass;
                homeTeamCell.setAttribute('nowrap', '');
                homeTeamCell.title = game.status;
                homeTeamCell.textContent = game.home_team;
                
                const homeScoreCell = document.createElement('td');
                homeScoreCell.id = `g${gameIndex}nfl${rowIndex}r1c${colIndex * 2 + 1}p`;
                homeScoreCell.className = ptsClass;
                homeScoreCell.setAttribute('nowrap', '');
                homeScoreCell.align = 'right';
                homeScoreCell.title = game.status;
                homeScoreCell.textContent = game.status === 'Scheduled' ? '0' : game.home_score;
                
                tr2.appendChild(homeTeamCell);
                tr2.appendChild(homeScoreCell);
                
                // Row 3: Status
                const statusCell = document.createElement('td');
                statusCell.id = `g${gameIndex}nfl${rowIndex}rs`;
                statusCell.className = statusClass;
                statusCell.setAttribute('nowrap', '');
                statusCell.colSpan = 2;
                statusCell.title = game.status;
                // Show game time for scheduled and in-progress games
                if (game.status === 'Scheduled' && game.game_time) {
                    const timeWithDay = convertToPST(game.game_time, game.game_time_epoch);
                    // If it includes a day, split it into two lines for the scoreboard
                    if (game.game_time_epoch && timeWithDay.includes(' ')) {
                        const parts = timeWithDay.split(' ');
                        if (parts.length >= 3) {
                            // Format as "Sunday\n10:00 AM"
                            statusCell.innerHTML = parts[0] + '<br>' + parts.slice(1).join(' ');
                        } else {
                            statusCell.textContent = timeWithDay;
                        }
                    } else {
                        statusCell.textContent = timeWithDay;
                    }
                } else if (game.status === 'Halftime') {
                    // Always show "Halftime" for halftime games
                    statusCell.textContent = 'Halftime';
                } else if (game.status === 'InProgress' && game.game_time) {
                    statusCell.textContent = game.game_time;
                } else {
                    statusCell.textContent = game.status;
                }
                
                tr3.appendChild(statusCell);
                
                // Add hover and click effects
                const cells = [awayTeamCell, awayScoreCell, homeTeamCell, homeScoreCell, statusCell];
                cells.forEach(cell => {
                    cell.addEventListener('mouseenter', () => highlightGame(cells, true));
                    cell.addEventListener('mouseleave', () => highlightGame(cells, false));
                    // Add click handler to open CBS Sports game page
                    cell.addEventListener('click', () => {
                        if (game.game_url) {
                            window.open(game.game_url, '_blank');
                        }
                    });
                });
            });
            
            tbody.appendChild(tr1);
            tbody.appendChild(tr2);
            tbody.appendChild(tr3);
        });
        
        // Show the NFL games div
        document.getElementById('nfldiv').style.display = 'block';
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function(event) {
        const urlData = parseUrl();
        if (urlData.matchup) {
            currentMatchupId = parseInt(urlData.matchup);
            loadMatchup(currentMatchupId);
        }
    });
    
    // Removed visibilitychange listener - deltas should persist when switching tabs

    // Clean up on unload
    window.onbeforeunload = function() {
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }
    };
</script>
</body>
</html>