<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <title>Statfink - PFL Fantasy Football</title>
    <link href="/statfink-styles.css" rel="stylesheet" type="text/css" media="all" />
</head>
<body onload="read_cont()">
    <div id="controls" class="controls">
        <div id="updatemsg" style="display: inline-block; font-size: 11px; color: #333;"></div>
    </div>
    <div id="lastupdate" class="lastupdate"></div>

    <div id="leaguediv">
        <table class="leaguetable" id="leaguetable" width="250">
            <thead></thead>
            <tbody>
                <tr>
                    <td class="fleague" id="fleague" colspan="2" nowrap="nowrap">Loading...</td>
                </tr>
            </tbody>
            <tfoot></tfoot>
        </table>
        <div style="text-align: center; padding: 10px 0;">
            <img src="/statfink_logo.png" alt="Statfink Fantasy Football Stat Tracker" style="width: 100%; max-width: 240px; height: auto;">
        </div>
        <div id="nfldiv" class="nfldiv">
            <table class="nfltable" id="nfltable" width="250">
                <thead></thead>
                <tbody>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
    </div>
    <div id="teams">
        <div id="team0div">
            <table class="matchuptable" id="team0" width="325px">
                <thead></thead>
                <tbody>
                    <tr id="fteam0row">
                        <td class="fteam" id="fteam0" colspan="5" nowrap="nowrap">Loading...</td>
                    </tr>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
        <div id="team1div">
            <table class="matchuptable" id="team1" width="325px">
                <thead></thead>
                <tbody>
                    <tr id="fteam1row">
                        <td class="fteam" id="fteam1" colspan="5" nowrap="nowrap">Loading...</td>
                    </tr>
                </tbody>
                <tfoot></tfoot>
            </table>
        </div>
    </div>
</body>

<script>
    // Configuration
    var bench = 0;
    var breakout = 0;
    var matchup = 0;
    var view = 0;
    var league = "pfl";
    var weekover = 0;
    var iterations = 0;
    var teamchange = 1;
    var lastupdate = 0;
    var live = 1;
    var nextgame = 0;
    var currentMatchupId = null;
    var currentWeek = null;
    var currentSeason = null;
    var refreshInterval = null;
    var showDetails = false;
    var currentMatchupData = null;

    // Initialize layout
    if (view == 0) {
        document.getElementById("team0div").className = "floatleftpad";
        document.getElementById("team1div").className = "floatleft";
        document.getElementById("team0").className = "floatleft";
    }
    document.getElementById("teams").className = "absteams";
    document.getElementById("leaguediv").className = "absleague";

    // No menu handlers needed anymore
    

    // Removed menu handlers - no longer needed

    // Matchup row event handlers
    function matchupmouseover(e) {
        const target = e.currentTarget; // Use currentTarget to get the row, not the cell
        const rowId = target.id;
        if (!rowId) return;
        
        const matchIndex = rowId.substring(2, 3);
        const row1 = document.getElementById(`lm${matchIndex}r0`);
        const row2 = document.getElementById(`lm${matchIndex}r1`);
        
        if (row1) row1.className = "matchuprowhover";
        if (row2) row2.className = "matchuprowhover";
    }

    function matchupmouseout(e) {
        const target = e.currentTarget; // Use currentTarget to get the row, not the cell
        const rowId = target.id;
        if (!rowId) return;
        
        const matchIndex = rowId.substring(2, 3);
        const originalClass = matchIndex % 2 ? "matchuprow2" : "matchuprow1";
        const row1 = document.getElementById(`lm${matchIndex}r0`);
        const row2 = document.getElementById(`lm${matchIndex}r1`);
        
        if (row1) row1.className = originalClass;
        if (row2) row2.className = originalClass;
    }

    // Toggle details view
    function toggleDetails() {
        showDetails = !showDetails;
        if (currentMatchupData) {
            displayMatchup(currentMatchupData);
        }
    }

    // Open matchup in new window
    function openMatchupWindow() {
        if (currentMatchupId) {
            window.open(`/statfink/${currentSeason}/${currentWeek}?matchup=${currentMatchupId}`, '_blank');
        }
    }

    // Show injuries (placeholder)
    function showInjuries() {
        alert("Injuries feature coming soon!");
    }

    // Show defensive TDs (placeholder)
    function showDefensiveTDs() {
        alert("Defensive TDs feature coming soon!");
    }

    // Show safeties (placeholder)
    function showSafeties() {
        alert("Safeties feature coming soon!");
    }

    // Check for zero scores
    function checkZeroScores() {
        if (!currentMatchupData) return;
        
        let zeroPlayers = [];
        currentMatchupData.team1.starters.forEach(player => {
            if (player.stats.fantasy_points === 0) {
                zeroPlayers.push(`${currentMatchupData.matchup.team1_name}: ${player.name}`);
            }
        });
        currentMatchupData.team2.starters.forEach(player => {
            if (player.stats.fantasy_points === 0) {
                zeroPlayers.push(`${currentMatchupData.matchup.team2_name}: ${player.name}`);
            }
        });
        
        if (zeroPlayers.length > 0) {
            alert("Players with zero points:\n" + zeroPlayers.join("\n"));
        } else {
            alert("No players with zero points!");
        }
    }

    // Show scores file (placeholder)
    function showScoresFile() {
        alert("Scores file feature coming soon!");
    }
    

    // Parse URL to get year, week, and mode
    function parseUrl() {
        const path = window.location.pathname;
        const urlParams = new URLSearchParams(window.location.search);
        const matchupParam = urlParams.get('matchup');
        
        // Check if this is mock mode
        if (path.includes('/statfink/mock')) {
            return {
                isMock: true,
                matchup: matchupParam
            };
        }
        
        // Parse /statfink/year/week format
        const pathParts = path.split('/');
        if (pathParts.length >= 4 && pathParts[1] === 'statfink') {
            const year = parseInt(pathParts[2]);
            const week = parseInt(pathParts[3]);
            
            if (!isNaN(year) && !isNaN(week)) {
                return {
                    year: year,
                    week: week,
                    matchup: matchupParam,
                    isMock: false
                };
            }
        }
        
        // Fallback to query parameters for backwards compatibility
        return {
            year: urlParams.get('season'),
            week: urlParams.get('week'),
            matchup: matchupParam,
            isMock: false
        };
    }

    // Main initialization
    async function read_cont() {
        try {
            // Parse URL for year/week/mode
            const urlData = parseUrl();
            
            // Load league settings
            const settingsResponse = await fetch('/api/league/settings');
            const settings = await settingsResponse.json();
            
            if (settings.success) {
                // Use URL parameters if available, otherwise use current settings
                currentWeek = parseInt(urlData.week) || settings.data.current_week;
                currentSeason = parseInt(urlData.year) || settings.data.season_year;
                
                // Check for mock mode
                if (urlData.isMock) {
                    document.getElementById("fleague").innerHTML = `Week ${currentWeek}<br>Mock Mode`;
                    document.getElementById("updatemsg").innerHTML = "MOCK DATA - Testing Mode";
                    document.getElementById("updatemsg").style.color = "#ff6600";
                    document.getElementById("updatemsg").style.fontWeight = "bold";
                } else {
                    document.getElementById("fleague").innerHTML = `Week ${currentWeek}`;
                }
            }

            // Load matchups for current week
            await loadWeekMatchups();
            
            // Load NFL games
            await loadNFLGames();
            
            // If specific matchup requested, load it
            if (urlData.matchup) {
                currentMatchupId = parseInt(urlData.matchup);
                await loadMatchup(currentMatchupId);
            } else if (matchup === 0 && document.getElementById("leaguetable").rows.length > 1) {
                // Load first matchup by default
                document.getElementById("leaguetable").rows[1].click();
            }

            // Start refresh interval (30 seconds) - but not in mock mode to avoid API calls
            if (!urlData.isMock) {
                refreshInterval = setInterval(refreshData, 30000);
            }
            
        } catch (error) {
            console.error('Error initializing:', error);
            document.getElementById("fleague").textContent = "Error loading league data";
        }
    }

    // Load all matchups for the week
    async function loadWeekMatchups() {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock/${currentWeek}/${currentSeason}`
                : `/api/matchups/${currentWeek}/${currentSeason}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                const tbody = document.getElementById("leaguetable").getElementsByTagName("tbody")[0];
                
                // Keep the header row
                while (tbody.rows.length > 1) {
                    tbody.deleteRow(1);
                }
                
                // Add matchup rows in original format
                data.data.forEach((matchup, index) => {
                    // Team 1 row
                    const row1 = tbody.insertRow(-1);
                    row1.className = index % 2 ? "matchuprow2" : "matchuprow1";
                    row1.id = `lm${index}r0`;
                    row1.onclick = () => selectMatchup(matchup.matchup_id);
                    row1.onmouseover = matchupmouseover;
                    row1.onmouseout = matchupmouseout;
                    
                    const team1Cell = row1.insertCell(0);
                    team1Cell.textContent = `${matchup.team1_owner} (0)`;
                    team1Cell.nowrap = true;
                    
                    const score1Cell = row1.insertCell(1);
                    score1Cell.textContent = matchup.team1_points.toFixed(2);
                    score1Cell.align = "right";
                    score1Cell.className = "fanpts";
                    score1Cell.nowrap = true;
                    
                    // Team 2 row
                    const row2 = tbody.insertRow(-1);
                    row2.className = index % 2 ? "matchuprow2" : "matchuprow1";
                    row2.id = `lm${index}r1`;
                    row2.onclick = () => selectMatchup(matchup.matchup_id);
                    row2.onmouseover = matchupmouseover;
                    row2.onmouseout = matchupmouseout;
                    
                    const team2Cell = row2.insertCell(0);
                    team2Cell.textContent = `${matchup.team2_owner} (0)`;
                    team2Cell.nowrap = true;
                    
                    const score2Cell = row2.insertCell(1);
                    score2Cell.textContent = matchup.team2_points.toFixed(2);
                    score2Cell.align = "right";
                    score2Cell.className = "fanpts";
                    score2Cell.nowrap = true;
                    
                    if (index === 0) {
                        currentMatchupId = matchup.matchup_id;
                    }
                });
                
                updateLastUpdate();
            }
        } catch (error) {
            console.error('Error loading matchups:', error);
        }
    }

    // Select and load a specific matchup
    async function selectMatchup(matchupId) {
        currentMatchupId = matchupId;
        await loadMatchup(matchupId);
        
        // Update browser URL to reflect current matchup
        updateUrlWithMatchup(matchupId);
    }
    
    // Update browser URL with current matchup
    function updateUrlWithMatchup(matchupId) {
        const currentPath = window.location.pathname;
        const isMockMode = currentPath.includes('/statfink/mock');
        
        let newUrl;
        if (isMockMode) {
            newUrl = `/statfink/mock/${currentWeek}/${currentSeason}?matchup=${matchupId}`;
        } else {
            newUrl = `/statfink/${currentSeason}/${currentWeek}?matchup=${matchupId}`;
        }
        
        // Update URL without reloading the page
        history.pushState({ matchupId: matchupId }, '', newUrl);
    }


    // Load matchup details
    async function loadMatchup(matchupId) {
        try {
            // Check if we're in mock mode
            const isMockMode = window.location.pathname.includes('/statfink/mock');
            const apiUrl = isMockMode 
                ? `/api/matchups/mock-game/${matchupId}`
                : `/api/matchups/game/${matchupId}`;
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                currentMatchupData = data.data;
                displayMatchup(data.data);
                updateLastUpdate();
            }
        } catch (error) {
            console.error('Error loading matchup:', error);
        }
    }

    // Display matchup data
    function displayMatchup(data) {
        const matchup = data.matchup;
        
        // Calculate players remaining (will be implemented later)
        const team1Remaining = 0;
        const team2Remaining = 0;
        
        // Update team headers
        document.getElementById("fteam0").innerHTML = `${matchup.team1_owner} (${team1Remaining})`;
        document.getElementById("fteam1").innerHTML = `${matchup.team2_owner} (${team2Remaining})`;
        
        // Build team tables
        displayTeamRoster("team0", data.team1.starters, matchup.team1_name);
        displayTeamRoster("team1", data.team2.starters, matchup.team2_name);
    }

    // Display team roster
    function displayTeamRoster(tableId, starters, teamName) {
        const table = document.getElementById(tableId);
        const tbody = table.getElementsByTagName("tbody")[0];
        
        // Clear existing rows except header
        while (tbody.rows.length > 1) {
            tbody.deleteRow(1);
        }
        
        // Add header row
        const headerRow = tbody.insertRow(-1);
        headerRow.className = "pointsrow";
        headerRow.innerHTML = `
            <td>Pos</td>
            <td>Player</td>
            <td align="right" nowrap>Game Status</td>
            <td class="opp">Opp</td>
            <td align="right">FanPts</td>
        `;
        
        let totalPoints = 0;
        let rowIndex = 0;
        
        starters.forEach(player => {
            const points = player.stats ? player.stats.fantasy_points : 0;
            totalPoints += points;
            
            // Player row
            const row = tbody.insertRow(-1);
            row.className = rowIndex % 2 ? "playerrow2" : "playerrow1";
            row.id = `t${tableId.slice(-1)}r${rowIndex}`;
            
            const isStarter = player.roster_position === 'starter';
            const hasPoints = points > 0;
            const playerName = (isStarter && hasPoints) ? `*${player.name}` : player.name;
            
            row.innerHTML = `
                <td class="position position-${player.position}">${player.position}</td>
                <td class="playername" nowrap>${playerName} &nbsp;&nbsp;${player.team}<br>
                    <span style="font-size: 10px; color: #000; margin-top: 3px; display: block;">${formatPlayerStatsCompact(player.position, player.stats)}</span>
                </td>
                <td class="status" align="center">Final</td>
                <td class="opp">${player.opp || '@OPP'}</td>
                <td class="points fanpts" align="right">${points.toFixed(2)}</td>
            `;
            
            rowIndex++;
        });
        
        // Add total row
        const totalRow = tbody.insertRow(-1);
        totalRow.className = "totalsrow";
        totalRow.innerHTML = `
            <td colspan="4" class="fanptsbig">Net Points</td>
            <td class="fanptsbig" align="right">${totalPoints.toFixed(2)}</td>
        `;
    }

    // Format player stats based on position
    function formatPlayerStats(position, stats) {
        if (!stats) return 'No stats available';
        
        let details = [];
        
        switch(position) {
            case 'QB':
                if (stats.passing_yards > 0) details.push(`${stats.passing_yards} pass yds`);
                if (stats.passing_tds > 0) details.push(`${stats.passing_tds} pass TD`);
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} rush yds`);
                if (stats.rushing_tds > 0) details.push(`${stats.rushing_tds} rush TD`);
                if (stats.interceptions > 0) details.push(`${stats.interceptions} INT`);
                break;
            case 'RB':
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} rush yds`);
                if (stats.rushing_tds > 0) details.push(`${stats.rushing_tds} rush TD`);
                if (stats.receptions > 0) details.push(`${stats.receptions} rec`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} rec yds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} rec TD`);
                break;
            case 'WR':
            case 'TE':
                if (stats.receptions > 0) details.push(`${stats.receptions} rec`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} rec yds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} rec TD`);
                break;
            case 'K':
                if (stats.field_goals_made > 0) details.push(`${stats.field_goals_made}/${stats.field_goals_attempted} FG`);
                if (stats.extra_points_made > 0) details.push(`${stats.extra_points_made}/${stats.extra_points_attempted} XP`);
                break;
            case 'DST':
            case 'DEF':
                if (stats.sacks > 0) details.push(`${stats.sacks} sacks`);
                if (stats.def_interceptions > 0) details.push(`${stats.def_interceptions} INT`);
                if (stats.fumbles_recovered > 0) details.push(`${stats.fumbles_recovered} FR`);
                if (stats.def_touchdowns > 0) details.push(`${stats.def_touchdowns} TD`);
                if (stats.points_allowed !== undefined) details.push(`${stats.points_allowed} PA`);
                if (stats.yards_allowed !== undefined) details.push(`${stats.yards_allowed} YA`);
                break;
        }
        
        return details.join(', ') || 'No stats';
    }

    // Format player stats in compact form like original Statfink
    function formatPlayerStatsCompact(position, stats) {
        if (!stats) return '0 Stats';
        
        let details = [];
        
        switch(position) {
            case 'QB':
                if (stats.completions > 0) details.push(`${stats.completions} Comp`);
                if (stats.passing_attempts - stats.completions > 0) details.push(`${stats.passing_attempts - stats.completions} Inc`);
                if (stats.passing_yards > 0) details.push(`${stats.passing_yards} Pyds`);
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} Rshyds`);
                if (stats.passing_tds + stats.rushing_tds > 0) details.push(`${stats.passing_tds + stats.rushing_tds} TDs`);
                if (stats.two_point_conversions_pass > 0) details.push(`${stats.two_point_conversions_pass} 2PC`);
                break;
            case 'RB':
                if (stats.rushing_yards > 0) details.push(`${stats.rushing_yards} Rshyds`);
                if (stats.receptions > 0) details.push(`${stats.receptions} Recs`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} Recyds`);
                if (stats.rushing_tds + stats.receiving_tds > 0) details.push(`${stats.rushing_tds + stats.receiving_tds} TDs`);
                if (stats.two_point_conversions_run + stats.two_point_conversions_rec > 0) {
                    details.push(`${stats.two_point_conversions_run + stats.two_point_conversions_rec} 2PC`);
                }
                break;
            case 'WR':
            case 'TE':
                if (stats.receptions > 0) details.push(`${stats.receptions} Recs`);
                if (stats.receiving_yards > 0) details.push(`${stats.receiving_yards} Recyds`);
                if (stats.receiving_tds > 0) details.push(`${stats.receiving_tds} TDs`);
                if (stats.two_point_conversions_rec > 0) details.push(`${stats.two_point_conversions_rec} 2PC`);
                break;
            case 'K':
                if (stats.field_goals_made > 0) details.push(`${stats.field_goals_made} FG`);
                if (stats.extra_points_made > 0) details.push(`${stats.extra_points_made} XP`);
                break;
            case 'DST':
            case 'DEF':
                if (stats.sacks > 0) details.push(`${stats.sacks} Sck`);
                if (stats.def_interceptions > 0) details.push(`${stats.def_interceptions} Int`);
                if (stats.fumbles_recovered > 0) details.push(`${stats.fumbles_recovered} FR`);
                if (stats.def_touchdowns > 0) details.push(`${stats.def_touchdowns} TD`);
                if (stats.points_allowed !== undefined) details.push(`${stats.points_allowed} PA`);
                if (stats.yards_allowed !== undefined) details.push(`${stats.yards_allowed} YA`);
                break;
        }
        
        if (details.length === 0) {
            return '0 Stats';
        }
        
        return details.join(', ');
    }

    // Update last update time
    async function updateLastUpdate() {
        try {
            const response = await fetch('/api/league/sync-status');
            const data = await response.json();
            
            if (data.success && data.data.last_sync_time) {
                const syncTime = new Date(data.data.last_sync_time);
                document.getElementById("lastupdate").textContent = `Last Tank01 Sync: ${syncTime.toLocaleString()}`;
            } else {
                const now = new Date();
                document.getElementById("lastupdate").textContent = `Last Update: ${now.toLocaleTimeString()}`;
            }
        } catch (error) {
            console.error('Error fetching sync status:', error);
            const now = new Date();
            document.getElementById("lastupdate").textContent = `Last Update: ${now.toLocaleTimeString()}`;
        }
        
        // Update the message next to Options
        document.getElementById("updatemsg").textContent = "Updated 6-10-25, 11:35pm - All games are over, come back next week.";
    }

    // Refresh data
    async function refreshData() {
        if (currentMatchupId) {
            await loadMatchup(currentMatchupId);
        }
        await loadWeekMatchups();
        await loadNFLGames();
    }

    // Highlight NFL game on hover
    function highlightGame(cells, highlight) {
        cells.forEach(cell => {
            if (highlight) {
                // Store original classes
                cell.dataset.originalClass = cell.className;
                // Apply highlight classes
                if (cell.className.includes('pts')) {
                    cell.className = 'nflhlpts';
                } else if (cell.className.includes('status')) {
                    cell.className = 'nflhlstatus';
                } else {
                    cell.className = 'nflhl';
                }
            } else {
                // Restore original classes
                if (cell.dataset.originalClass) {
                    cell.className = cell.dataset.originalClass;
                }
            }
        });
    }
    
    // Load NFL games for the week
    async function loadNFLGames() {
        try {
            const response = await fetch(`/api/nfl-games/${currentWeek}/${currentSeason}`);
            const data = await response.json();
            
            if (data.success && data.data.length > 0) {
                displayNFLGames(data.data);
            }
        } catch (error) {
            console.error('Error loading NFL games:', error);
        }
    }
    
    // Display NFL games in grid format
    function displayNFLGames(games) {
        const tbody = document.getElementById('nfltable').getElementsByTagName('tbody')[0];
        tbody.innerHTML = ''; // Clear existing content
        
        // Group games into rows (4 games per row)
        const gamesPerRow = 4;
        const rows = [];
        
        for (let i = 0; i < games.length; i += gamesPerRow) {
            rows.push(games.slice(i, i + gamesPerRow));
        }
        
        // Create table rows with exact HTML structure
        rows.forEach((rowGames, rowIndex) => {
            // Create rows using exact HTML from reference
            const tr1 = document.createElement('tr');
            tr1.id = `nfl${rowIndex}r0`;
            
            const tr2 = document.createElement('tr');
            tr2.id = `nfl${rowIndex}r1`;
            
            const tr3 = document.createElement('tr');
            tr3.id = `nfl${rowIndex}rs`;
            
            // Process each game in this row
            rowGames.forEach((game, colIndex) => {
                const gameIndex = rowIndex * gamesPerRow + colIndex;
                
                // Create checkered pattern based on row and column position
                const isEven = (rowIndex + colIndex) % 2 === 0;
                const baseClass = isEven ? 'nfl1' : 'nfl2';
                const ptsClass = isEven ? 'nfl1pts' : 'nfl2pts';
                const statusClass = isEven ? 'nfl1status' : 'nfl2status';
                
                // Row 1: Away team and score
                const awayTeamCell = document.createElement('td');
                awayTeamCell.id = `g${gameIndex}nfl${rowIndex}r0c${colIndex * 2}`;
                awayTeamCell.className = baseClass;
                awayTeamCell.setAttribute('nowrap', '');
                awayTeamCell.title = game.status;
                awayTeamCell.textContent = game.away_team;
                
                const awayScoreCell = document.createElement('td');
                awayScoreCell.id = `g${gameIndex}nfl${rowIndex}r0c${colIndex * 2 + 1}p`;
                awayScoreCell.className = ptsClass;
                awayScoreCell.setAttribute('nowrap', '');
                awayScoreCell.align = 'right';
                awayScoreCell.title = game.status;
                awayScoreCell.textContent = game.away_score;
                
                tr1.appendChild(awayTeamCell);
                tr1.appendChild(awayScoreCell);
                
                // Row 2: Home team and score
                const homeTeamCell = document.createElement('td');
                homeTeamCell.id = `g${gameIndex}nfl${rowIndex}r1c${colIndex * 2}`;
                homeTeamCell.className = baseClass;
                homeTeamCell.setAttribute('nowrap', '');
                homeTeamCell.title = game.status;
                homeTeamCell.textContent = game.home_team;
                
                const homeScoreCell = document.createElement('td');
                homeScoreCell.id = `g${gameIndex}nfl${rowIndex}r1c${colIndex * 2 + 1}p`;
                homeScoreCell.className = ptsClass;
                homeScoreCell.setAttribute('nowrap', '');
                homeScoreCell.align = 'right';
                homeScoreCell.title = game.status;
                homeScoreCell.textContent = game.home_score;
                
                tr2.appendChild(homeTeamCell);
                tr2.appendChild(homeScoreCell);
                
                // Row 3: Status
                const statusCell = document.createElement('td');
                statusCell.id = `g${gameIndex}nfl${rowIndex}rs`;
                statusCell.className = statusClass;
                statusCell.setAttribute('nowrap', '');
                statusCell.colSpan = 2;
                statusCell.title = game.status;
                statusCell.textContent = game.status;
                
                tr3.appendChild(statusCell);
                
                // Add hover effects
                const cells = [awayTeamCell, awayScoreCell, homeTeamCell, homeScoreCell, statusCell];
                cells.forEach(cell => {
                    cell.addEventListener('mouseenter', () => highlightGame(cells, true));
                    cell.addEventListener('mouseleave', () => highlightGame(cells, false));
                });
            });
            
            tbody.appendChild(tr1);
            tbody.appendChild(tr2);
            tbody.appendChild(tr3);
        });
        
        // Show the NFL games div
        document.getElementById('nfldiv').style.display = 'block';
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function(event) {
        const urlData = parseUrl();
        if (urlData.matchup) {
            currentMatchupId = parseInt(urlData.matchup);
            loadMatchup(currentMatchupId);
        }
    });

    // Clean up on unload
    window.onbeforeunload = function() {
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }
    };
</script>
</body>
</html>